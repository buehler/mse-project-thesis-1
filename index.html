<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christoph Bühler" />
  <meta name="keywords" content="Authentication, Distributed, Trust, Microservices, Kubernetes" />
  <title>Distributed Authentication Mesh</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Distributed Authentication Mesh</h1>
<p class="subtitle">Declarative Adhoc Conversion of Credentials</p>
<p class="author">Christoph Bühler</p>
<p class="date"><p>Spring Semester 2021<br />
University of Applied Science of Eastern Switzerland (OST)</p></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#definitions-and-boundaries">Definitions and Boundaries</a>
<ul>
<li><a href="#context">Context</a></li>
<li><a href="#kubernetes">Kubernetes</a>
<ul>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#sec:kubernetes_operator">Operator</a></li>
<li><a href="#sec:kubernetes_sidecar">Sidecar</a></li>
<li><a href="#sec:service_mesh">Service Mesh</a></li>
</ul></li>
<li><a href="#authentication-and-authorization">Authentication and Authorization</a>
<ul>
<li><a href="#sec:basic_auth">Basic (RFC7617)</a></li>
<li><a href="#sec:auth_oidc">OpenID Connect (OIDC)</a></li>
</ul></li>
</ul></li>
<li><a href="#state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</a>
<ul>
<li><a href="#state-of-the-art">State of the Art</a></li>
<li><a href="#the-practice">The Practice</a></li>
<li><a href="#sec:deficiencies">Deficiencies</a></li>
</ul></li>
<li><a href="#distributed-authentication-mesh">Distributed Authentication Mesh</a>
<ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#non-functional-requirements">Non-Functional Requirements</a></li>
<li><a href="#contrast">Contrast</a>
<ul>
<li><a href="#saml">SAML</a></li>
<li><a href="#sec:ws-deathstar">WS-*</a></li>
</ul></li>
<li><a href="#architecture">Architecture</a>
<ul>
<li><a href="#brief-description">Brief Description</a></li>
<li><a href="#use-case">Use Case</a></li>
<li><a href="#solution-architecture">Solution Architecture</a></li>
<li><a href="#communication">Communication</a></li>
</ul></li>
<li><a href="#implementation-proof-of-concept-poc">Implementation Proof of Concept (PoC)</a>
<ul>
<li><a href="#showcase-application">Showcase Application</a></li>
<li><a href="#operator">Operator</a></li>
<li><a href="#envoy-sidecar">Envoy Sidecar</a></li>
<li><a href="#translator-1">Translator</a></li>
</ul></li>
</ul></li>
<li><a href="#evaluation">Evaluation</a></li>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#further-work">Further Work</a></li>
</ul></li>
<li><a href="#bibliography">Bibliography</a></li>
<li><a href="#appendix-a-installation-guide-for-poc">Appendix A: Installation Guide for PoC</a></li>
<li><a href="#appendix-b-teaching-material-for-kubernetes-operators">Appendix B: Teaching Material for Kubernetes Operators</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Modern cloud environments solve many problems like the discovery of services and data transfer or communiation between services in general. One modern way of solving service discovery and communication is a Service Mesh, which introduces an additional infrastructure layer that manages the communication between services <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>.</p>
<p>However, a specific problem is not solved yet: “dynamic” trusted communication between services. When a service, that is capable of handling OpenID Connect (OIDC) credentials, wants to communicate with a service that only knows Basic Authentication that originating service must implement some sort of conversion or know static credentials to communicate with the basic auth service. Generally, this introduces changes to the software of services. In small applications which consist of one or two services, implementing this conversion may be a feasable option. If we look at an application which spans over a big landscape and a multitude of services, implementing each and every possible authentication mechanism and the according conversions will be error prone work and does not scale well<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>The goal of the project “Distributed Authentication Mesh” is to provide a solution for this problem.</p>
<p>Prerequisits:</p>
<ul>
<li>Docker knowledge</li>
<li>Microservice knowledge</li>
</ul>
<blockquote>
<p>TODO.</p>
</blockquote>
<h1 id="definitions-and-boundaries">Definitions and Boundaries</h1>
<p>This section provides general information about the project, the context and prerequisite knowledge. It gives an overview of the context as well as terminology and general definitions.</p>
<h2 id="context">Context</h2>
<blockquote>
<p>TODO: restructure to have better reading flow</p>
</blockquote>
<p>This project addresses the specific problem of declarative conversion of credentials to ensure authorized communication between services. The solution may be runnable on various platforms but will be implemented according to Kubernetes standards. Kubernetes<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is an orchestration platform that works with containerized applications. The solution introduces an operator pattern, as explained in Section <a href="#sec:kubernetes_operator">2.2.3</a></p>
<p>The deliverables of this and further projects may aid applications or APIs to communicate with each other despite different authentication mechanisms. As an example, this could be used to enable a modern web application that uses OpenID Connect (OIDC) as the authentication and authorization mechanism to communicate with a legacy application that was deployed on the Kubernetes cluster but not yet rewritten. This transformation of credentials (from OIDC to Basic Auth) is done by the solution of the projects instead of manual work which may introduc code changes to either service.</p>
<p>This specific project provides a proof of concept (PoC) with an initial version on a GitHub repository. The PoC demonstrates that it is possible to instruct an Envoy<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> proxy to communicate with an injected service to modify authentication credentials in-flight.</p>
<p>To use the proposed solution of this project, no service mesh or other complex layer is needed. The solution runs without those additional parts on a Kubernetes cluster. To provide service discovery, the default internal DNS capabilities of Kubernetes are sufficient.</p>
<h2 id="kubernetes">Kubernetes</h2>
<h3 id="introduction-1">Introduction</h3>
<p>Kubernetes is an open source platform that manages containerized workloads and applications. Workloads may be accessed via “Services” that use a DNS naming system. Kubernetes uses declarative definitions to compare the actual state of the system with the expected state <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<div id="fig:kubernetes_container_evolution" class="fignos">
<figure>
<img src="images/Kubernetes/Container_Evolution.png" data-short-caption="Kubernetes Container Evolution" alt="Figure 1: Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes (CNCF 2021). This image is licensed under the CC BY 4.0 license (Creative Commons 2021)." /><figcaption aria-hidden="true"><span>Figure 1:</span> Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>. This image is licensed under the CC BY 4.0 license <span class="citation" data-cites="cc:CCBY4.0">(Creative Commons 2021)</span>.</figcaption>
</figure>
</div>
<p>According to Kubernetes, the way of deploying applications has evolved. As shown in Figure <a href="#fig:kubernetes_container_evolution">1</a>, the “Traditional Era” was the time, when applications were deployed via FTP access and started manually (e.g. on an Apache webserver). Then the revolution to virtual machines came and technologies that could virtualize a whole operating system, such as VMWare, were born. The latest stage, “Container Era,” defines a new way deploying workloads by virtualizing processes instead of operating systems and therefore better use the given resources <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<p>Kubernetes is a major player, among others like “Docker Swarm” or “Cloud Foundry,” in “Container Deployment” as seen in Figure <a href="#fig:kubernetes_container_evolution">1</a> and supports teams with the following features according to the documentation <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>:</p>
<ul>
<li><strong>Service discovery and load balancing</strong>: Use DNS names or IP addresses to route traffic to a container and if the traffic is high and multiple instances are available, Kubernetes does load balance the traffic</li>
<li><strong>Storage orchestration</strong>: Automatically provide storage in the form of mountable volumes</li>
<li><strong>Automated rollouts and rollbacks</strong>: When a new desired state is provided Kubernetes tries to achieve the state at a controlled rate and has the possibility of performing rollbacks</li>
<li><strong>Automatec bin packing</strong>: Kubernetes only needs to know how much CPU and RAM a workload needs and then takes care of placing the workload on a fitting node in the cluster</li>
<li><strong>Self-healing</strong>: If workloads are failing, Kubernetes tries to restart the applications and even kills services that do not respond to the configured health checks</li>
<li><strong>Secret and configuration management</strong>: Kubernetes has a store for sensitive data as well as configurational data that may change the behaviour of a workload</li>
</ul>
<p>The list of features is not complete. There are many concepts in Kubernetes which help to build complex deployment scenarios and enable teams to ship their applications in an agile manner.</p>
<p>Kubernetes works with containerized applications. In contrast to “plain” Docker, it orchestrates the applications and is responsible to reach the desired state depicted in the applications manifest files. Examples of such manifests can be viewed at: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#creating-a-deployment.</p>
<h3 id="terminology">Terminology</h3>
<p>In Table <a href="#tbl:kubernetes_terminology">1</a>, we state the most common Kubernetes terminology. The table provides a list of terms that will be used to explain concepts like the operator pattern in Section <a href="#sec:kubernetes_operator">2.2.3</a>.</p>
<div id="tbl:kubernetes_terminology" class="tablenos">
<table id="tbl:kubernetes_terminology" style="width:92%;">
<caption><span>Table 1:</span> Common Kubernetes Terminology </caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Docker</td>
<td>Container runtime. Enables developers to create images of applications. Those images are then run in an isolated environment. Docker images are often used in Kubernetes to define the application that Kubernetes should run.</td>
</tr>
<tr class="even">
<td>Kustomize</td>
<td>“Kustomize” is a special templating CLI to declaratively bundle Kubernetes manifests. It consists of a <code>kustomization.yaml</code> and various referenced manifest yaml files. It is declarative and does not allow dynamic structures. It helps administrators to template applications for Kubernetes.</td>
</tr>
<tr class="odd">
<td>Container</td>
<td>Smallest possible unit in a deployment. Contains the definition of the workload. A container consists of a container image, arguments, volumes and other specific information to carry out a task.</td>
</tr>
<tr class="even">
<td>Pod</td>
<td>Composed of multiple containers. Is ran by Kubernetes as an instance of a deployment. Pods may be scaled according to definitions or “pod scalers.” Highly coupled tasks are deployed together in a pod (i.e. multiple coupled containers in a pod).</td>
</tr>
<tr class="odd">
<td>Deployment</td>
<td>A deployment is a managed instance of a pod. Kubernetes will run the described pod with the desired replica count on the best possible worker node. Deployments may be scaled with auto-scaling mechanisms.</td>
</tr>
<tr class="even">
<td>Service</td>
<td>A service enables communciation with one or multiple pods. The service contains a selector that points to a certain number of pods and then ensures that the pods are accessable via a DNS name. The name is typically a combination of the servicename and the namespace (e.g. <code>my-service.namespace</code>).</td>
</tr>
<tr class="odd">
<td>Ingress</td>
<td>Incomming communication and data-flow into a component. Furthermore an “Ingress” is a Kubernetes object that defines incomming communication and configures an API gateway to route traffic to specific services.</td>
</tr>
<tr class="even">
<td>Egress</td>
<td>Outgoing communication. Egress means communication from a component to another (when the component is the source).</td>
</tr>
<tr class="odd">
<td>Resource</td>
<td>A resource is something that can be managed by Kubernetes. It defines an API endpoint on the master node and allows Kubernetes to store a collection of such API objects. Examples are: <code>Deployment</code>, <code>Service</code> and <code>Pod</code>, to name a few of the built-in resources.</td>
</tr>
<tr class="even">
<td>CRD</td>
<td>A Custom Resource Definition (CRD) enables developers to extend the default Kubernetes API. With a CRD, it is possible to create own resources which creates an API endpoint on the Kubernetes API. An example of such a CRD is the <code>Mapping</code> resource of Ambassador<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</td>
</tr>
<tr class="odd">
<td>Operator</td>
<td>An operator is a software that manages Kubernetes resources and their lifecycle. Operators may use CRDs to define custom objects on which they react when some event (<code>Added</code>, <code>Modified</code> or <code>Deleted</code>) triggers on a resource. For a more in-depth description, see Section <a href="#sec:kubernetes_operator">2.2.3</a>.</td>
</tr>
<tr class="even">
<td>Watcher</td>
<td>A watcher is a constant connection from a client to the Kubernetes API. The watcher defines some search and filter parameters and receives events for the found resources.</td>
</tr>
<tr class="odd">
<td>Validator</td>
<td>A validator is a service that may reject the creation, modification or deletion of resources.</td>
</tr>
<tr class="even">
<td>Mutator</td>
<td>Mutators are called before Kubernetes validates and stores a resource. Mutators may return JSON patches <strong>RFC6902</strong> <span class="citation" data-cites="RFC6902">(Bryan and Nottingham 2013)</span> to instruct Kubernetes to modify a resource prior to validating and storing them.</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>TODO: UML of kubernetes parts</p>
</blockquote>
<h3 id="sec:kubernetes_operator">Operator</h3>
<p>An operator in Kubernetes is an extension to the Kubernetes API itself. A custom operator typically manages the whole lifecycle of an appliction it manages <span class="citation" data-cites="dobies:KubernetesOperators">(Dobies and Wood 2020)</span>. Such a custom operator can further be used to reconcile normal Kubernetes resources or any combination thereof.</p>
<p>Some examples of application operators are:</p>
<ul>
<li>Prometheus Operator<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>: Manages instances of Prometheus in a cluster</li>
<li>Postgres Operator<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>: Manages PostgreSQL clusters inside Kubernetes, with the support of multiple instance database clusters</li>
</ul>
<p>There exists a broad list of operators, which can be (partially) viewed on <a href="https://operatorhub.io/">operatorhub.io</a>.</p>
<div id="fig:kubernetes_operator_workflow" class="fignos">
<figure>
<img src="diagrams/sequences/63233dbd018a21fb1e6ec4e33958bf09.png" alt="Figure 2: Kubernetes Operator Workflow" /><figcaption aria-hidden="true"><span>Figure 2:</span> Kubernetes Operator Workflow</figcaption>
</figure>
</div>
<p>In Figure <a href="#fig:kubernetes_operator_workflow">2</a>, we depict the general workflow of an event that is managed by an operator. When an operator is installed and running on a Kubernetes cluster, it registers “Resource Watchers” with the API and receives notifications when the master node modifies resources a watched resource. The overviewed events are “Added,” “Modified” and “Deleted.” There are two additional events that may be returned by the API (“Error” and “Bookmark”) but they are typically not needed in an operator.</p>
<p>When the user interacts with the Kubernetes API (for example via the <code>kubectl</code> executable) and creates a new instance of a resource, the API will first call any “Mutator” in a serial manner. After the mutators, the API will call any “Validators” in parallel and if no validator objects against the creation, the API will then store the resource and tries to apply the transition for the new desired state. Now, the operator receives the notification about the watched resource and may interact with the event. Such an action may include to update resources, create more resources or even delete other instances.</p>
<h3 id="sec:kubernetes_sidecar">Sidecar</h3>
<p>According to <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">Burns and Oppenheimer (2016)</span>, the sidecar pattern is the most common pattern for multi-container deployments <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, sec. 4.1)</span>. Sidecars are containers that enhance the functionality of the main container in a pod. An example for such a sidecar is a log collector, that collects log files written to the file system and forwards them towards some log processing software <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, sec. 4.1)</span>. Another example is the Google CloudSQL Proxy<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, which provides access to a CloudSQL instance from a pod without routing the whole traffic through Kubernetes services.</p>
<div id="fig:kubernetes_sidecar" class="fignos">
<figure>
<img src="diagrams/component/fea6395d89219670b7e904c4f382c3a5.png" data-short-caption="Example of a sidecar container" alt="Figure 3: Sidecar container extending a main container in a pod. As example, this could be a log collector , figure 1(Burns and Oppenheimer 2016, fig. 1)." /><figcaption aria-hidden="true"><span>Figure 3:</span> Sidecar container extending a main container in a pod. As example, this could be a log collector <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, fig. 1)</span>.</figcaption>
</figure>
</div>
<p>The example shown in Figure <a href="#fig:kubernetes_sidecar">3</a> is extensible. Such sidecars may be injected by a mutator or an operator to extend functionality.</p>
<p>Common usecases for sidecars are controlling the data flow in a cluster in service mesh, providing access to secure locations or performing additional tasks such as collecting logs of an application. Since sidecars are tightly coupled to the original application, they scale with the Pod. It is not possible to scale a sidecar without scaling the Pod - and therefore the application - itself.</p>
<h3 id="sec:service_mesh">Service Mesh</h3>
<p>A “Service Mesh” is a dedicated infrastructure layer that handles intercommunication between services. It is responsible for the delivery of requests in a modern cloud application <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>. An example from the practice is “Istio”<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. When using Istio, the applications do not need to know if there is a service mesh installed or not. Istio will inject a sidecar (see Section <a href="#sec:kubernetes_sidecar">2.2.4</a>) into pods and handle the communication with the injected services.</p>
<p>The service mesh provides a set of features <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>:</p>
<ul>
<li><strong>Service discovery</strong>: The mechanism to locate and communicate with a workload / service. In a cloud environment, the location of services will likely change, thus the service mesh provides a way to access the services in the cloud.</li>
<li><strong>Load balancing</strong>: As an addition to the service discovery, the mesh provides load balancing mechanisms as is done by Kubernetes itself.</li>
<li><strong>Fault tolerance</strong>: The router in a service mesh is responsible to route traffic to healthy services. If a service is unavailable or even reports a crash, traffic should not be routed to this instance.</li>
<li><strong>Traffic monitoring</strong>: In contrast to the default Kubernetes possibilities, with a service mesh, the traffic from and to various services can be monitored in detail. This offers the opportunity to derive reports per target, success rates and other metrics.</li>
<li><strong>Circuit breaking</strong>: The ability to cut off an overloaded service and back off the remaining requests instead of totally failing the service under stress. A circuit breaker pattern measures the failure rate of a service and applies states to the service: “Closed” - requests are passed to the service, “Open” - requests are not passed to this instance, “Half-Open” - only a limited number is passed <span class="citation" data-cites="montesi:CircuitBreakers">(Montesi and Weber 2016, sec. 2)</span>.</li>
<li><strong>Authentication and access control</strong>: Through the control plane, a service mesh may define the rules of communication. It defines which services can communicate with one another.</li>
</ul>
<p>As observed in the list above, many of the features of a service mesh are already provided by Kubernetes. Service discovery, load balancing, fault tolerance and - though limited - traffic monitoring is already possible with Kubernetes. Introducing a service mesh into a cluster enables administrators to build more complex scenarios and deployments.</p>
<h2 id="authentication-and-authorization">Authentication and Authorization</h2>
<h3 id="sec:basic_auth">Basic (RFC7617)</h3>
<p>The <code>Basic</code> authentication scheme is a trivial authentication that accepts a username and a password encoded in Base64. To transmit the credentials, a construct with the schematics of <code>&lt;username&gt;:&lt;password&gt;</code> is created and inserted into the http request as the <code>Authorization</code> header with the prefix <code>Basic</code> <span class="citation" data-cites="RFC7617">(Reschke 2015, sec. 2)</span>. An example with the username <code>ChristophBuehler</code> and password <code>SuperSecure</code> would result in the following header:</p>
<blockquote>
<p><code>Authorization: Basic Q2hyaXN0b3BoQnVlaGxlcjpTdXBlclNlY3VyZQ==</code></p>
</blockquote>
<h3 id="sec:auth_oidc">OpenID Connect (OIDC)</h3>
<p>OpenID Connect is not defined in a RFC, the specification is provided by the OpenID Foundation (OIDF). OIDC however, builds on top of OAuth, which is defined by <strong>RFC6749</strong>.</p>
<p>OpenID Connect is an authenticating scheme, that builds upon the <code>OAuth 2.0</code> authorization protocol. OAuth itself is an authorization framework, that enables applications to gain access to a service (API or other) <span class="citation" data-cites="RFC6749">(Hardt and others 2012, abstract)</span>. OAuth 2.0 deals with authorization only and grants access to data and features on a specific application. OAuth by itself does not define <em>how</em> the credentials are transmitted and exchanged <span class="citation" data-cites="RFC6749">(Hardt and others 2012)</span>. OIDC adds a layer on top of OAuth 2.0 that defines <em>how</em> these credentials must be exchanged. This adds login and profile capabilities to any application that uses OIDC <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014)</span>.</p>
<div id="fig:oidc_code_flow" class="fignos">
<figure>
<img src="diagrams/sequences/120c5686c778e2c9541dd4fa276c6cf5.png" data-short-caption="OIDC code flow" alt="Figure 4: OIDC code authorization flow (Sakimura et al. 2014). Only contains the credential flow, without the explicit OAuth part. OAuth handles the authorization whereas OIDC handles the authentication." /><figcaption aria-hidden="true"><span>Figure 4:</span> OIDC code authorization flow <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014)</span>. Only contains the credential flow, without the explicit OAuth part. OAuth handles the authorization whereas OIDC handles the authentication.</figcaption>
</figure>
</div>
<p>When a user wants to authenticate himself with OIDC, one of the possible “flows” is the “Authorization Code Flow” <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.1)</span>. Other possible flows are the “Implicit Flow” <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.2)</span> and the “Hybrid Flow” <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.3)</span>. Figure <a href="#fig:oidc_code_flow">4</a> depicts the “Authorization Code Flow.” A user that wants to access a certain resource on a relying party (i.e. something that relies on the information about the user) and is not authenticated and authorized, the relying party forwards the user to the identity provider (IdP). The user provides his credentials to the IdP and is returned to the relying party with an authorization code. The relying party can then exchange the authorization code to valid tokens on the token endpoint of the IdP. Typically, <code>access_token</code> and <code>id_token</code> are provided. While the <code>id_token</code> must be a JSON Web Token (JWT) <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 2)</span>, the <code>access_token</code> can be in any format <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.3.3.8)</span>.</p>
<p>An example of an <code>id_token</code> in JWT format may be:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre>
<p>The stated JWT token contains:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;alg&quot;</span><span class="fu">:</span> <span class="st">&quot;HS256&quot;</span><span class="fu">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;typ&quot;</span><span class="fu">:</span> <span class="st">&quot;JWT&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="st">&quot;1234567890&quot;</span><span class="fu">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;John Doe&quot;</span><span class="fu">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;iat&quot;</span><span class="fu">:</span> <span class="dv">1516239022</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<h1 id="state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</h1>
<p>This section gives an overview over the current state of the art, the practice, as well as the deficiencies to a desired situation.</p>
<h2 id="state-of-the-art">State of the Art</h2>
<p>In cloud environments, a problem that is solved is the transmission of data from one point to another. Kubernetes, for example, uses “Services” that provide a DNS name for a specified workload. For service meshes, additionally a sidecar is injected into the Pod that contains - in the case of “Istio” - an Envoy proxy to handle data transmission.</p>
<p>In terms of authentication and authorization, there exist a variety of schemes that enable an application to authenticate and authorize their users. OpenID Connect (OIDC) (see Section <a href="#sec:auth_oidc">2.3.2</a>) is a modern authentication scheme, that builds upon OAuth 2.0, that in turn handles authorization <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014)</span>.</p>
<p>Modern software architectures that are specifically designed for the cloud are called “Cloud Native Applications” (CNA). <span class="citation" data-cites="kratzke:CloudNativeApplications">Kratzke and Peinl (2016)</span> define a CNA as:</p>
<blockquote>
<p>“A cloud-native application is a distributed, elastic and horizontal scalable system composed of (micro)services which isolates state in a minimum of stateful components. The application and each self-contained deployment unit of that application is designed according to cloud-focused design patterns and operated on a self-service elastic platform.” <span class="citation" data-cites="kratzke:CloudNativeApplications">(Kratzke and Peinl 2016, sec. 3)</span>.</p>
</blockquote>
<p>However, with CNAs and the general movement to cloud environments and digitalization, not all applications get that chance to adjust. For various reasons like budget, time or complexity, legacy applications and monoliths are not refactored or re-written before they are deployed into a cloud environment. If the legacy applications are mixed with modern systems, then the need of “translation” arises. Assuming, that the modern part is a secure application, that uses OIDC to authorize its users and the application needs to fetch data from the legacy system that does not understand OIDC, code changes must be made. Following the previous assumption, the code changes will likely be introduced into the modern application, since it is better maintainable and deployable than the legacy monolith. Hence, the modern application receives changes that may introduce new bugs or security vulnerabilities.</p>
<div id="fig:is_solution_components" class="fignos">
<figure>
<img src="diagrams/component/185dad86b9b22e16344879cadd317645.png" data-short-caption="Microservice Architecture with legacy components" alt="Figure 5: Microservice Architecture that contains modern applications as well as legacy services." /><figcaption aria-hidden="true"><span>Figure 5:</span> Microservice Architecture that contains modern applications as well as legacy services.</figcaption>
</figure>
</div>
<p>We consider the components in Figure <a href="#fig:is_solution_components">5</a>:</p>
<ul>
<li><strong>User</strong>: A person with access to the application</li>
<li><strong>Client</strong>: A modern single page application (SPA)</li>
<li><strong>IAM</strong>: Identity Provider for the solution (does not necessarily reside in the same cloud)</li>
<li><strong>Service A</strong>: A modern API application and primary access point for the client</li>
<li><strong>Service B</strong>: Legacy service that is called by service a to fetch some additional data</li>
</ul>
<p>In the practice, we encountered the stated scenario at various points in time. Legacy services may not be the primary use-case, a nother case is the usage of third party applications which only support certain authentication mechanisms and the code is not accessable.</p>
<div id="fig:is_solution_process" class="fignos">
<figure>
<img src="diagrams/sequences/7643f25471f1496284331c5e302b3cce.png" data-short-caption="Current process of legacy communication" alt="Figure 6: Current state of the art of accessing legacy systems from modern services with differing authentication schemes." /><figcaption aria-hidden="true"><span>Figure 6:</span> Current state of the art of accessing legacy systems from modern services with differing authentication schemes.</figcaption>
</figure>
</div>
<p>The process in Figure <a href="#fig:is_solution_process">6</a> shows the process of communication in such a described scenario. In Figure <a href="#fig:is_solution_process">6</a>, the “Client” is the single page application (SPA), that authenticates against an arbitrary Identity and Access Management System (IAM). “Service A” is the modern backend that supports the client as backend API. Therefore, “Service A” provides functionality for the client. “Service B” is a legacy application, for example an old ERP with order information, that was moved into the cloud, but is not refactored nor rewritten to communicate with modern authentication technologies.</p>
<p>In this scenario, the client calls some API on “Service A” that then will call “Service B” to get additional information to present to the user. Since the client and “Service A” communicate with the same authentication technology, the call is straight forward. The client authenticates himself and obtains an access token. When calling the service (“Service A”), the token is transmitted and the service can check with the IAM if the user is authorized to access the system. When “Service A” then calls “Service B” for additional information, it needs to translate the user provided credentials to a format that “Service B” understands. In the provided example, “Service B” is only able to handle Basic Authentication, as explained in Section <a href="#sec:basic_auth">2.3.1</a>. This means, if “Service A” wants to communicate with “Service B,” it must implement some translation logic to change the credentials to a format that B understands. This introduces code changes to “Service A,” since “Service B” is a legacy application that is not maintainable.</p>
<h2 id="the-practice">The Practice</h2>
<p>In practice, no current solution exists, that allows credentials to be transformed between authentication schemes. The service mesh “Istio” provides a mechanism to secure services that communicate with mTLS (mutual TLS) <span class="citation" data-cites="istio:website:mtls">(Istio Authors 2021b)</span> as well as an external mechanism to provide custom authentication and authorization capabilities <span class="citation" data-cites="istio:website:custom-authz">(Istio Authors 2021a)</span>. This works well when all applications in the system share the same authentication scheme. As soon as two or more schemes are in place, the need for transformation arises again.</p>
<h2 id="sec:deficiencies">Deficiencies</h2>
<p>The situation described in the previous sections introduces several problems. It does not matter if “Service B” is a third party application to which no code changes can be applied to, or if it is a legacy application that cannot be updated for the time being. Most likely, the code change to provide the ability to communicate will be introduced into “Service A.” This adds the risk of errors since new code must be produced, which would not be necessary if the legacy service would be refactored. Also, changing “Service A” to communicate with B may be a feasible solution in a small setup. But as the landscape of the microservice architecture grows, this solution does not scale well. The matrix problem <span class="math inline"><em>X</em> services * <em>Y</em> authentication methods</span> describes this problematic. As the landscape and the different methods of authentication grows, it is not a feasible solution to implement each and every authentication scheme in all the services.</p>
<p>Another issue that emerges with this transformation of credentials: The credentials leak into the trust zone. As long as each service is in the same trust zone (for example in the same data-center in the same cluster behind the same API gateway), this may not be problematic. As soon as communication is between data centers, the communication and the credentials must be protected. It is not possible to create a zero trust environment with the need of knowledge about the targets authentication schemes.</p>
<p>The usage of a service mesh to mitigate the problem is not an option since the initial problem of transforming credential still persists. Service meshes may provide a way to secure communication between services, but they are not able to transform credentials to a required format for any legacy application. Furthermore, service meshes introduce configurational complexity to the system which, in our opinion, is not needed without a clear usecase for a service mesh.</p>
<h1 id="distributed-authentication-mesh">Distributed Authentication Mesh</h1>
<p>This section gives a general overview of the proposed solution. Furthermore, boundaries of the solution are provided along with common software engineering elements like requirements, non-functional requirements and the documentation of the architecture.</p>
<p>The proposed architecture may be used as generic description for a solution to the described problem. For this project, the solution is implemented specifically to work within a Kubernetes cluster. The delivery of this project is a proof of concept to provide insights into the general topic of manipulating HTTP requests in-flight.</p>
<h2 id="definition">Definition</h2>
<p>The solution to solve the stated problems in Section <a href="#sec:deficiencies">3.3</a> must be able to transform arbitrary credentials into a format that the target service understands. For this purpose, the architecture contains a service which runs as a sidecar among the target service. This sidecar intercepts requests to the target and transforms the Authorization HTTP header. The sidecar is - like in a service mesh - used to intercept inbound and outbound traffic.</p>
<p>However, the solution <strong>must not</strong> interfere with the data flow itself. The problem of proxying data from point A to B is a well solved problem. In the given work, an Envoy proxy is used to deliver data between the services. Envoy allows the usage of an external service to modify requests in-flight.</p>
<h2 id="requirements">Requirements</h2>
<p>In Table <a href="#tbl:functional-requirements">2</a>, we present the list of requirements (REQ) for the proposed solution.</p>
<div id="tbl:functional-requirements" class="tablenos">
<table id="tbl:functional-requirements" style="width:89%;">
<caption><span>Table 2:</span> Functional Requirements </caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>REQ 1</td>
<td>The translator module must be able to transform given credentials into the specified common language and the common format back into valid credentials.</td>
</tr>
<tr class="even">
<td>REQ 2</td>
<td>The translator is injected as a sidecar into the solution. In Kubernetes this is done via an operator.</td>
</tr>
<tr class="odd">
<td>REQ 3</td>
<td>Beside the translator, an Envoy proxy is injected to the service inquestion to handle the data flow. This injection is also performed by the operator.</td>
</tr>
<tr class="even">
<td>REQ 4</td>
<td>Translators do only modify HTTP headers, they do not interfere with the data that is transmitted. Any information that needs to be forwarded must be within the HTTP headers.</td>
</tr>
<tr class="odd">
<td>REQ 5</td>
<td></td>
</tr>
<tr class="even">
<td>REQ 6</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>It is important to note that the implemented proof of concept (PoC) will not meet all requierements. Further work is needed to implement a solution according to the architecture that adheres the stated requirements.</p>
<h2 id="non-functional-requirements">Non-Functional Requirements</h2>
<p>In Table <a href="#tbl:non-functional-requirements">3</a>, we show the non-functional requirements (NFR) for the proposed solution.</p>
<div id="tbl:non-functional-requirements" class="tablenos">
<table id="tbl:non-functional-requirements" style="width:89%;">
<caption><span>Table 3:</span> Non-Functional Requirements </caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NFR 1</td>
<td>First and foremost, the solution <strong>must not</strong> be less secure than current solutions.</td>
</tr>
<tr class="even">
<td>NFR 2</td>
<td>The solution must adhere to current best practices and security mechanisms. Furthermore, it <strong>must</strong> be implemented with security issues as stated in the OWASP Top Ten (<a href="https://owasp.org/www-project-top-ten" class="uri">https://owasp.org/www-project-top-ten</a>) in mind.</td>
</tr>
<tr class="odd">
<td>NFR 3</td>
<td>The concept of the solution is applicable to cluster orchestration software other than Kubernetes. The architecture provides a general way of solving the stated problem instead of giving a proprietary solution for one vendor.</td>
</tr>
<tr class="even">
<td>NFR 4</td>
<td>The translation of the credentials should not extensively impact the timeframe of an arbitrary request. In production mode, the additional time to check and transform the credentials should not extend 100ms.</td>
</tr>
<tr class="odd">
<td>NFR 5</td>
<td>The solution is modular. It can be extended with additional “translators” which provide the means of transforming the given credentials to other target formats.</td>
</tr>
<tr class="even">
<td>NFR 6</td>
<td>The solution may run with or without a service mesh. It is a goal that the solution can run without a service mesh to reduce the overall complexity, but if a service mesh is already in place, the solution must be able to work with the provided elements.</td>
</tr>
<tr class="odd">
<td>NFR 7</td>
<td>The architecture must be scaleable. The provided software must be able to scale according to the business needs of the overall system.</td>
</tr>
<tr class="even">
<td>NFR 8</td>
<td>Each translator should only handle one authentication scheme to ensure separation of concerns and scalability of the whole solution.</td>
</tr>
<tr class="odd">
<td>NFR 9</td>
<td>The solution</td>
</tr>
</tbody>
</table>
</div>
<p>Like the requirements in Table <a href="#tbl:functional-requirements">2</a>, the PoC will not meet all NFRs that are stated in Table <a href="#tbl:non-functional-requirements">3</a>. Further work is needed to complete the PoC to a production ready software.</p>
<h2 id="contrast">Contrast</h2>
<p>To distinguish this solution from other software, this sections gives a contrast to two specific topics. The given topics stand for a general architectural idea and the contrast to the presented solution.</p>
<h3 id="saml">SAML</h3>
<p>The “Security Assertion Markup Language” (SAML) is a so called “Federated Identity Management” (FIdM) standard. SAML, OAuth and OIDC represent the three most popular FIdm standards <span class="citation" data-cites="naik:SAMLandFIdM">(Naik and Jenkins 2017)</span>. SAML is an XML framework for transmitting user data, such as authentication, entitlement and other attributes, between services and organizations <span class="citation" data-cites="naik:SAMLandFIdM">(Naik and Jenkins 2017)</span>.</p>
<p>While SAML is a partial solution for the stated problem, it does not cover the use case when credentials need to be transformed to communicate with a legacy system. SAML enables services to share identities in a trustful way but all communicating partners must implement the SAML protocol to be part of the network. This project addresses the specific transformation of credentials into a format for some legacy systems. The basic idea of SAML however, may be used as a baseline of security and the general idea of processing identities.</p>
<h3 id="sec:ws-deathstar">WS-*</h3>
<p>The term “WS-*” contains a broad class of specifications within the WSDL/SOAP context. The specifications were created by the World Wide Web Consortium (W3C) but never finished and officially published.</p>
<p>The “Simple Object Access Protocol” (SOAP) is a protocol to exchange information between services in an XML encoded message <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>. It provides a way of communication between web services. A SOAP message consists of an “envelope” that contains a “body” and an optional “header” to transfer encoded objects <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>. An example SOAP message from <span class="citation" data-cites="curbera:SOAP-and-WSDL">Curbera et al. (2002)</span> looks like this:</p>
<pre><code>POST /travelservice
SOAPAction: &quot;http://www.acme-travel.com/checkin&quot;
Content-Type: text/xml; charset=&quot;utf-8&quot;
Content-Length: nnnn

&lt;SOAP:Envelope xmlns:SOAP=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
  &lt;SOAP:Body&gt;
    &lt;et:eTicket xmlns:et=&quot;http://www.acme-travel.com/eticket/schema&quot;&gt;
      &lt;et:passengerName first=&quot;Joe&quot; last=&quot;Smith&quot;/&gt;
      &lt;et:flightInfo
        airlineName=&quot;AA&quot;
        flightNumber=&quot;1111&quot;
        departureDate=&quot;2002-01-01&quot;
        departureTime=&quot;1905&quot;/&gt;
    &lt;/et:eTicket&gt;
  &lt;/SOAP:Body&gt;
&lt;/SOAP:Envelope&gt;</code></pre>
<p>The “Web Services Description Language” (WSDL), however, is an XML based description of a web service. The goal of WSDL is to provide a description of methods that may be called on a web service <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>. WSDL fills the needed endpoint description that SOAP is missing. While SOAP provides basic communication, WSDL defines the exact methods that can be called on an endpoint <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>.</p>
<p>The proposed solution differs from WS-* such that there is no exact specification needed for the target service. While the solution contains a common domain language - a SOAP like protocol to encode data - it does not specify the endpoints of a service. The solution merely interacts with the HTTP request that targets a specific service and transforms the credentials from the common format to the specific format. Of course, certain authentication schemes need specific information to generate their credentials out of the data.</p>
<h2 id="architecture">Architecture</h2>
<p>The following sections provide an architectural overview over the proposed solution. The solution is described in prosa text, as well as usual software engineering diagrams with explanations. First, a description of the solution gives an introduction about the idea, then the architecture shows the general overview of the solution followed by sequence and communication definitions.</p>
<p>The reader should note, that the proposed architecture does not match the implementation of the PoC to the full extent. The goal of this project is to provide a generalizable idea to implement such a solution, while the PoC proves the ability of modifying HTTP requests in-flight.</p>
<h3 id="brief-description">Brief Description</h3>
<p>In general, when some service wants to communicate with another service and the user does not need to authenticate himself for every service, probably a federated identity is used. This means, that at some point, the user validates his own identity and is then authenticated in the whole zone of trust.</p>
<p>To achieve such a federated identity with diverging authentication schemes, the solution converts validated credentials to a common language format. This format, in conjunction with a proof of the sender, validates the identity over the wire in the communication between services without the need of additional authentication. When all parties of a communication are trusted through verification, no information about the effective credentials leak into the communication between services.</p>
<p>The basic idea of the solution is to remove any credentials from an outgoing HTTP request with the common format of the users identity and replace the common format in the ingoing HTTP request into the valid credentials of the given scheme.</p>
<h3 id="use-case">Use Case</h3>
<p>The usefulness of such a solution shows when “older” or monolythic software moves to the cloud or when third party software is used that provides no accessable source code.</p>
<p><strong>Communicate with legacy software</strong></p>
<p>Precondition: Cloud native application and legacy software are deployed with their respective manifests and the sidecars are running.</p>
<ol type="1">
<li>The user is authenticated against the CNA</li>
<li>The user tries to access a resource on the legacy software</li>
<li>The CNA creates a request and “forwards” the credentials of the user</li>
<li>The proxy intercepts the request and forwards the credentials to the transformer</li>
<li>The transformer verifies the credentials and transforms them into a common format</li>
<li>The proxy replaces the headers and forwards the request</li>
<li>The receiving proxy forwards the common format to the translator of the target</li>
<li>The translator casts the credentials into the specific authentication scheme credentials</li>
<li>The receiving proxy forwards the request with the updated HTTP headers</li>
</ol>
<p>Postcondition: The communication has taken place and no credentials have left the source service (CNA). Furthermore, the legacy service does not know what credentials or what specific authentication scheme was used.</p>
<p>This use case can be changed such that the receiving service is not a legacy software but an old and non-maintained application that is deployed into a cloud environment without refactoring. Another possibility could be some third party application where the source code is not accessable.</p>
<h3 id="solution-architecture">Solution Architecture</h3>
<p>In this section, we describe the system architecture of the proposed solution. The architecture is shown in a diagram and then broken down to the individual parts.</p>
<div id="fig:solution_architecture" class="fignos">
<figure>
<img src="diagrams/component/64a23481728552507fb1db28a0e0409c.png" alt="Figure 7: Solution Architecture" /><figcaption aria-hidden="true"><span>Figure 7:</span> Solution Architecture</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:solution_architecture">7</a> shows the general solution architecture. In the “support” package, general available elements are presented. The solution needs a public key infrastructure (PKI) to deliver key material for signing and validation purposes. Furthermore a configuration and secret storage must be provided.</p>
<p>Additionally, an optional automation component watches and manages applications. In case of cloud environments, this component is strongly suggested to automate deployment configuration. The automation does inject the proxies, translators and the specific needed configurations for the managed components.</p>
<p>An application service consists of three parts. First, the source (or destination) service, which represents the deployed application itself, a translator that manages the transformation between the common language format of the identity and the implementation specific authentication format and a proxy that manages the communication from and to the application.</p>
<p>For the further sections, the architecture shows elements of a Kubernetes cloud environment. The reason is to describe the specific architecture in a practical way. However, the general idea of the solution may be deployed in various environments and is not bound to a cloud infrastructure.</p>
<h4 id="automation">Automation</h4>
<p>In case of a Kubernetes infrastructure, the automation part is done by an operator as explained in Section <a href="#sec:kubernetes_operator">2.2.3</a>.</p>
<div id="fig:automation_architecture" class="fignos">
<figure>
<img src="diagrams/component/8ab1636e46798db9773722c109061f37.png" alt="Figure 8: Automation Architecture" /><figcaption aria-hidden="true"><span>Figure 8:</span> Automation Architecture</figcaption>
</figure>
</div>
<p>The operator in Figure <a href="#fig:automation_architecture">8</a> watches the Kubernetes API for changes. When deployments or services are created, the operator enhances the respective elements. “Enhancing” in this context means, that additional pods (see Table <a href="#tbl:kubernetes_terminology">1</a>) are injected into a deployment as sidecars. The additional sidecars are the proxy and the translator. While the proxy manages incomming (“ingress”) and outgoing (“egress”) communication, the translator manages the transformation of credentials from and to a common format.</p>
<div id="fig:automation_process" class="fignos">
<figure>
<img src="diagrams/sequences/a7f1ebec352ed877efed8fbe59ee95ae.png" alt="Figure 9: Automation Process" /><figcaption aria-hidden="true"><span>Figure 9:</span> Automation Process</figcaption>
</figure>
</div>
<p>The process that enhances deployments is shown in Figure <a href="#fig:automation_process">9</a>. The operator registers a “watcher” for deployments and services with the Kubernetes API. Whenever a deployment or a service is created or modified, the operator receives a notification. Then, the operator checks of the object in question “is relevant” by checking if it is part of the authentication mesh. This participation can be configured - in the example of Kubernetes - via annotations, labels or any other means of configuration. If the object is relevant, depending on the type, the operator injects sidecars into the deployment or reconfigures the service to use the proxy as targeting port for the service communication.</p>
<h4 id="public-key-infrastructure-pki">Public Key Infrastructure (PKI)</h4>
<p>The role of the public key infrastructure in the solution is to build the trust anchor in the system.</p>
<div id="fig:pki_architecture" class="fignos">
<figure>
<img src="diagrams/component/645963aab3a61a7b8ff215236bd36369.png" alt="Figure 10: PKI Architecture" /><figcaption aria-hidden="true"><span>Figure 10:</span> PKI Architecture</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:pki_architecture">10</a> depicts the relation of the translators and the PKI. When a translator starts, it aquires trusted key material from the PKI (for example with a certificate signing request). This key material is then used to sign the identity that is transmitted to the receiving party. The receiving translator can validate the signature of the identity and the sending party. The proxies are responsible for the communication between the instances.</p>
<div id="fig:pki_process" class="fignos">
<figure>
<img src="diagrams/sequences/e33367b4750a02b2c209f2aaad89f1ed.png" alt="Figure 11: PKI Process" /><figcaption aria-hidden="true"><span>Figure 11:</span> PKI Process</figcaption>
</figure>
</div>
<p>The sequence in Figure <a href="#fig:pki_process">11</a> shows how the PKI is used by the translator to create key material for itself. When a translator starts, it checks if it already generated a private key and obtains the key (either by creating a new one or fetching the existing one). Then, a certificate signing request (CSR) is sent to the PKI. The PKI will then create a certificate with the CSR and return the signed certificate.</p>
<p>When communication happens, the proxy will forward the HTTP headers of the request to the translator which contains the transfered identity of the user in the DSL. In case of a JWT token, the transformer may now confirm the signature of the JWT token with the obtained certificate since it is signed by the same Certificate Authority (CA). Then the transformation may happen and the proxy forwards the communication to the destination.</p>
<p>To increase the security and mitigate the problem of leaking certificates, it is adviced to create short living certificates in the PKI and resign certificates periodically.</p>
<h4 id="networking">Networking</h4>
<p>Networking in the proposed solution works with a combination of routing and communication proxing. The general purpose of the networking element is to manage data transport between instances of the authentication mesh and route the traffic to the source / destination.</p>
<div id="fig:networking_architecture" class="fignos">
<figure>
<img src="diagrams/component/01deae0a6542469de62e7d6989f2fc13.png" alt="Figure 12: Networking Architecture" /><figcaption aria-hidden="true"><span>Figure 12:</span> Networking Architecture</figcaption>
</figure>
</div>
<p>As seen in Figure <a href="#fig:networking_architecture">12</a> the proxy is the mediator between source and destination of a communication. Furthermore, the proxy manages the translation by communicating with the translator to transform the identity of the authenticated user and transmit it to the destination where it gets transformed again. Additionally, with the aid of the PKI, the proxy can verify the identity of the sender via mTLS.</p>
<h5 id="ingress">Ingress</h5>
<div id="fig:inbound_networking_process" class="fignos">
<figure>
<img src="diagrams/sequences/d00cd1c4d8970579821bd8848d978c5e.png" alt="Figure 13: Inbound Networking Process" /><figcaption aria-hidden="true"><span>Figure 13:</span> Inbound Networking Process</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:inbound_networking_process">13</a> shows the general process during inbound request processing. When the proxy receives a request (in the given example by the configured Kubernetes service), it calls the translator with the HTTP request detail. The PoC is implemented with the “Envoy” proxy. Envoy allows an external service to perform “external authorization”<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> during which the external service may:</p>
<ul>
<li>Add new headers before reaching the destination</li>
<li>Overwrite headers before reaching the destination</li>
<li>Remove headers before reaching the destination</li>
<li>Add new headers before returning the result to the caller</li>
<li>Overwrite headers before returning the result to the caller</li>
</ul>
<p>The translator uses this concept to consume a specific and well-known header to read the identity of the authorized user in the common format. The identity is then validated and transformed to the authentication credentials needed by the destination. Then, the translator instructs Envoy to set the credentials for the upstream. In the PoC, this is done by setting the <code>Authorization</code> header to static Basic Auth credentials.</p>
<h5 id="egress">Egress</h5>
<div id="fig:outbound_networking_process" class="fignos">
<figure>
<img src="diagrams/sequences/f44f92a9e99ca16905bc31e8a50d3b6d.png" alt="Figure 14: Outbound Networking Process" /><figcaption aria-hidden="true"><span>Figure 14:</span> Outbound Networking Process</figcaption>
</figure>
</div>
<p>In Figure <a href="#fig:outbound_networking_process">14</a> the outbound (egress) traffic is described. The proxy needs to catch all traffic from the source and performs the reversed process (of Figure <a href="#fig:inbound_networking_process">13</a>) by transforming the provided information from the source to generate the common format with the users identity. This identity is then inserted into the HTTP headers and sent to the destination. At the sink, the process of Figure <a href="#fig:inbound_networking_process">13</a> takes place - if the sink is part of the authentication mesh.</p>
<h4 id="translator">Translator</h4>
<p>The translator is responsible for transforming the identity from and to the common domain specific language.</p>
<div id="fig:translator_architecture" class="fignos">
<figure>
<img src="diagrams/component/ebadee9d70724ba4fdda65dda9c8faac.png" alt="Figure 15: Translator Architecture" /><figcaption aria-hidden="true"><span>Figure 15:</span> Translator Architecture</figcaption>
</figure>
</div>
<p>In conjunction with the PKI, the translator can verify the validity and integrity of the incomming identity.</p>
<div id="fig:translator_process" class="fignos">
<figure>
<img src="diagrams/sequences/0965d3cff84e104c9a42c4efe7802504.png" alt="Figure 16: Translator Process" /><figcaption aria-hidden="true"><span>Figure 16:</span> Translator Process</figcaption>
</figure>
</div>
<p>When the translator receives a request to create the needed credentials, it performs the sequence of actions as stated in Figure <a href="#fig:translator_process">16</a>. First, the proxy will forward the needed data to the translator. Afterwards, the translator will check if the transported identity is valid and signed by an authorized party in the authentication mesh. When the credentials are valid, they are translated according to the implementation of the translator. The proxy is then instructed with the actions to replace the transported identity with the correct credentials to access the destination.</p>
<p>In the PoC, the proof of integrity is not implemented, but the transformation takes place, where a “Bearer Token”<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> is used to check if the user may access and then replaces the token with static Basic Auth credentials.</p>
<h3 id="communication">Communication</h3>
<p>The communication between the proxies must be secured. Furthermore, the identity that is transformed over the wire must be tamper proof. Two established formats would suffice: “SAML” and “JWT Tokens.” While both contain the possibility to hash their contents and thus secure them against modification, JWT tokens are better designed for HTTP headers, since in current OIDC environments, JWT tokens are already used as access and/or identity tokens. They provide a secure environment with public and private claim names <span class="citation" data-cites="RFC7519">(Jones, Bradley, and Sakimura 2015, sec. 4.2, sec. 4.3)</span>.</p>
<p>Other options could be:</p>
<ul>
<li>Simple JSON</li>
<li>YAML</li>
<li>XML</li>
<li>X509 Certificates</li>
<li>Any other structured format</li>
</ul>
<p>The problem with other structured formats is that tamper protection and encoding must be done manually. JWT tokens provide a specified way of attaching a hashed version of the whole content <span class="citation" data-cites="RFC7519">(Jones, Bradley, and Sakimura 2015)</span> and therefore provide a method of validating a JWT token if it is still valid and if the sender is trusted. If the receiving end has his key material from the same PKI (and therefore the same CA), it can check the certificate and the integrity of the JWT token. If the signature is correct, the JWT token has been issued by a trusted and registered instance of the authentication network.</p>
<p>X509 certificates - as defined in <strong>RFC5280</strong> <span class="citation" data-cites="RFC5280">(Cooper et al. 2008)</span> - introduce another valid way of transporting data and properties about something to another party. “Certificate Extensions” can be defined by “private communities” and are attached to the certificate itself <span class="citation" data-cites="RFC5280">(Cooper et al. 2008, sec. 4.2, sec. 4.2.2)</span>.</p>
<p>While X509 certificates could be used instead of JWT to transport this data, using certificates would enforce the translator to act as intermediate CA and create new certificates for each request. From our experience, creating, extracting and manipulating certificates, for example in C#, is not a task done easily. Since this solution should be as easy to use as it can be, manipulating certificates in translators does not seem to be a feasible option. For the sake of simplicity and the well known usage, further work to this project will probably use JWT tokens to transmit the users identity.</p>
<h2 id="implementation-proof-of-concept-poc">Implementation Proof of Concept (PoC)</h2>
<p>To provide a proof that the general idea of the solution is possible, a PoC is implemented during the work of this project. The solution is implemented with the following technologies and environments:</p>
<ul>
<li>Environment: The PoC is implemented on a Kubernetes environment to enable automation and easy deployment for testing</li>
<li>“Automation”: A Kubernetes operator, written in .NET (C#) with the “Dotnet Operator SDK”<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></li>
<li>“Proxy”: Envoy proxy which gets the needed configuration injected as Kubernetes ConfigMap file</li>
<li>“Translator”: A .NET (F#) application that uses the Envoy gRPC defintions to react to Envoy’s requests and poses as the external service for the external authorization</li>
<li>“Showcase App”: A solution of three applications that pose as demo case with:
<ul>
<li>“Frontend”: An ASP.NET static site application that authenticates itself against “Zitadel”<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></li>
<li>“Modern Service”: A modern ASP.NET api application that can verify an OIDC token from Zitadel</li>
<li>“Legacy Service”: A “legacy” ASP.NET api application that is only able to verify <code>Basic Auth</code> (RFC7617, see Section <a href="#sec:basic_auth">2.3.1</a>)</li>
</ul></li>
</ul>
<p>The PoC addresses the following questions:</p>
<ul>
<li>Is it possible intercept HTTP requests to an arbitrary service</li>
<li>Is it further possible to modify the HTTP headers of the request</li>
<li>Can a sidecar service transform given credentials from one format to another</li>
<li>Can a custom operator inject the following elements:
<ul>
<li>The correct configuration for Envoy to use external authentication</li>
<li>The translator module to transform the credentials</li>
</ul></li>
</ul>
<p>Based on the results of the PoC, the following further work may be realized:</p>
<ul>
<li>Specify the concrete common domain language to transport identities</li>
<li>Implement a secure way of transporting identities with validation of integrity</li>
<li>Provide a production ready solution of some translators and the operator</li>
<li>Integrate the solution with a service mesh</li>
<li>Provide a production ready documentation of the solution</li>
<li>Further investiage the possibility of hardening the communication between services (e.g. with mTLS)</li>
</ul>
<p>For the solution to be production ready, at least the secure communication channel between elements of the mesh as well as the common language format must be implemented. To be used in current cloud environments, an implementation in Kubernetes can provide insights on how to develop the solution for other orchestrators than Kubernetes.</p>
<h3 id="showcase-application">Showcase Application</h3>
<p>The showcase application is a demo to show the need and the particular usecase of the solution. The application resides in an open source repository under <a href="https://github.com/WirePact/poc-showcase-app" class="uri">https://github.com/WirePact/poc-showcase-app</a>.</p>
<p>When installed in a Kubernetes cluster, the user can open (depending on the local configuration) the URL to the frontend application<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>.</p>
<div id="fig:impl_components_showcase_app" class="fignos">
<figure>
<img src="diagrams/component/4032bc1798039526f4ad189449c70457.png" alt="Figure 17: Component Diagram of the Showcase Application" /><figcaption aria-hidden="true"><span>Figure 17:</span> Component Diagram of the Showcase Application</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:impl_components_showcase_app">17</a> gives an overview over the components in the showcase application. The system contains an ASP.NET Razor Page<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> application as the frontend, an ASP.NET API application with configured Zitadel OIDC authentication as “modern” backend service and another ASP.NET API application that only supports basic authentication as “legacy” backend. The frontend can only communicate with the modern API and the modern API is able to call an additional service on the legacy API.</p>
<div id="fig:seq_showcase_call" class="fignos">
<figure>
<img src="diagrams/sequences/b8f867df74e125c26dc64ba5b20e754e.png" alt="Figure 18: Sequence Diagram of the Showcase Call" /><figcaption aria-hidden="true"><span>Figure 18:</span> Sequence Diagram of the Showcase Call</figcaption>
</figure>
</div>
<p>In Figure <a href="#fig:seq_showcase_call">18</a>, we show the process of a user call in the showcase application. The user opens the web application and authenticates himself with Zitadel. After that, the user is presented with the application and can click the “Call API” button. The frontend application will call the modern backend API with the OIDC token and asks for customer and order data. The customer data is present on the modern API so it is directly returned. To query order data, the modern service relies on a legacy application which is only capable of basic authentication.</p>
<p>Depending on the configuration (i.e. the environment variable <code>USE_WIREPACT</code>), the modern service will call the legacy one with either transformed basic auth credentials (when <code>USE_WIREPACT=false</code>) or with the presented OIDC token (otherwise). Either way, the legacy API receives basic auth credentials and returns the data which then in turn is returned and presented to the user.</p>
<p>To install and run the showcase application without any interference of the operator or the rest of the solution, follow the installation guide in the readme on <a href="https://github.com/WirePact/poc-showcase-app" class="uri">https://github.com/WirePact/poc-showcase-app</a>. To install and use the whole PoC solution, please refer to the installation guide in the Appendix.</p>
<h3 id="operator">Operator</h3>
<blockquote>
<p>TODO</p>
</blockquote>
<h3 id="envoy-sidecar">Envoy Sidecar</h3>
<p>In the PoC, the proxy sidecar is an Envoy proxy with an injected configuration. The operator injects the sidecar whenever a <code>Deployment</code> is created or updated via the Kubernetes API. The operator attaches the proxy and adds several annotations that are used for communication with a <code>Mutation Webhook</code>. Furthermore, a <code>ConfigMap</code> with the envoy configuration is created during the webhook.</p>
<p>Two parts of the envoy configuration are crucial. First, the <code>filter_chain</code> of the inbound traffic listener contains a list of <code>http_filters</code>. Within this list of filters, the external authorization filter is added to force Envoy to check if an arbitrary request is allowed or not:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ... more config</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">http_filters</span><span class="kw">:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> envoy.filters.http.ext_authz</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">typed_config</span><span class="kw">:</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">&#39;@type&#39;</span><span class="kw">:</span><span class="at"> type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">transport_api_version</span><span class="kw">:</span><span class="at"> v3</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">grpc_service</span><span class="kw">:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">envoy_grpc</span><span class="kw">:</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="at">          </span><span class="fu">cluster_name</span><span class="kw">:</span><span class="at"> auth_translator</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">timeout</span><span class="kw">:</span><span class="at"> 1s</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">include_peer_certificate</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> envoy.filters.http.router</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># ... more config</span></span></code></pre></div>
<p>Second, the external authorization service must be added to the <code>clusters</code> list to be access via the configured name (<code>auth_translator</code>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ... more config</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> auth_translator</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">connect_timeout</span><span class="kw">:</span><span class="at"> 0.25s</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">type</span><span class="kw">:</span><span class="at"> STATIC</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">typed_extension_protocol_options</span><span class="kw">:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">envoy.extensions.upstreams.http.v3.HttpProtocolOptions</span><span class="kw">:</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">&#39;@type&#39;</span><span class="kw">:</span><span class="at"> type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">explicit_http_config</span><span class="kw">:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">http2_protocol_options</span><span class="kw">:</span><span class="at"> </span><span class="kw">{}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">load_assignment</span><span class="kw">:</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">cluster_name</span><span class="kw">:</span><span class="at"> auth_translator</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">endpoints</span><span class="kw">:</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">lb_endpoints</span><span class="kw">:</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="at">          </span><span class="kw">-</span><span class="at"> </span><span class="fu">endpoint</span><span class="kw">:</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="at">              </span><span class="fu">address</span><span class="kw">:</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="at">                </span><span class="fu">socket_address</span><span class="kw">:</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="at">                  </span><span class="fu">address</span><span class="kw">:</span><span class="at"> </span><span class="fl">127.0.0.1</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="at">                  </span><span class="fu">port_value</span><span class="kw">:</span><span class="at"> &lt;&lt;PORT_VALUE&gt;&gt;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co"># ... more config</span></span></code></pre></div>
<p>This configures Envoy to find the external authorization service on the local loopback IP on the configured port. Since gRPC is configured (<code>grpc_service: envoy_grpc: ...</code> in the filter config), http2 must be enabled for the communication. In a productive environment, timeouts should be set accordingly.</p>
<h3 id="translator-1">Translator</h3>
<blockquote>
<p>TODO</p>
</blockquote>
<h1 id="evaluation">Evaluation</h1>
<blockquote>
<p>TODO: show in an evaluation, that the provided solution is working and improves the situation</p>
</blockquote>
<h1 id="conclusion">Conclusion</h1>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="further-work">Further Work</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h1 id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-RFC6902" class="csl-entry" role="doc-biblioentry">
Bryan, Paul, and Mark Nottingham. 2013. <span>“Javascript Object Notation (<span>JSON</span>) Patch.”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc6902">https://tools.ietf.org/html/rfc6902</a>.
</div>
<div id="ref-burns:DesignPatternsForContainerSystems" class="csl-entry" role="doc-biblioentry">
Burns, Brendan, and David Oppenheimer. 2016. <span>“Design Patterns for Container-Based Distributed Systems.”</span> In <em>8th <span>USENIX</span> Workshop on Hot Topics in Cloud Computing (HotCloud 16)</em>. Denver, CO: <span>USENIX</span> Association. <a href="https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns">https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns</a>.
</div>
<div id="ref-github:kubernetesWebsite" class="csl-entry" role="doc-biblioentry">
CNCF. 2021. <span>“Kubernetes Website.”</span> <em>GitHub Repository</em>. <a href="https://github.com/kubernetes/website">https://github.com/kubernetes/website</a>; GitHub.
</div>
<div id="ref-RFC5280" class="csl-entry" role="doc-biblioentry">
Cooper, Dave, Sharon Boeyen, Stefan Santesson, Tim Polk, Russ Housley, and Stephen Farrell. 2008. <span>“<span class="nocase">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</span>.”</span> 5280. Internet Engineering Task Force <span>IETF</span>. <a href="https://doi.org/10.17487/RFC5280">https://doi.org/10.17487/RFC5280</a>.
</div>
<div id="ref-cc:CCBY4.0" class="csl-entry" role="doc-biblioentry">
Creative Commons. 2021. <span>“Attribution 4.0 International (CC BY 4.0).”</span> <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>.
</div>
<div id="ref-curbera:SOAP-and-WSDL" class="csl-entry" role="doc-biblioentry">
Curbera, F., M. Duftler, R. Khalaf, W. Nagy, N. Mukhi, and S. Weerawarana. 2002. <span>“Unraveling the Web Services Web: An Introduction to <span>SOAP</span>, <span>WSDL</span>, and <span>UDDI</span>.”</span> <em><span>IEEE</span> Internet Computing</em> 6 (2): 86–93. <a href="https://doi.org/10.1109/4236.991449">https://doi.org/10.1109/4236.991449</a>.
</div>
<div id="ref-dobies:KubernetesOperators" class="csl-entry" role="doc-biblioentry">
Dobies, Jason, and Joshua Wood. 2020. <em>Kubernetes Operators: Automating the Container Orchestration Platform</em>. " O’Reilly Media, Inc.".
</div>
<div id="ref-RFC6749" class="csl-entry" role="doc-biblioentry">
Hardt, Dick, and others. 2012. <span>“The <span>OAuth</span> 2.0 Authorization Framework.”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a>.
</div>
<div id="ref-istio:website:custom-authz" class="csl-entry" role="doc-biblioentry">
Istio Authors. 2021a. <span>“External Authorization.”</span> <em>Istio</em>. <a href="https://istio.io/latest/docs/tasks/security/authorization/authz-custom/">https://istio.io/latest/docs/tasks/security/authorization/authz-custom/</a>.
</div>
<div id="ref-istio:website:mtls" class="csl-entry" role="doc-biblioentry">
———. 2021b. <span>“Mutual TLS Migration.”</span> <em>Istio</em>. <a href="https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/">https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/</a>.
</div>
<div id="ref-RFC7519" class="csl-entry" role="doc-biblioentry">
Jones, Michael B., Bradley John, and Nat Sakimura. 2015. <span>“<span>JSON</span> Web Token (<span>JWT</span>).”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>.
</div>
<div id="ref-kratzke:CloudNativeApplications" class="csl-entry" role="doc-biblioentry">
Kratzke, N., and R. Peinl. 2016. <span>“ClouNS - a Cloud-Native Application Reference Model for Enterprise Architects.”</span> In <em>2016 IEEE 20th International Enterprise Distributed Object Computing Workshop (EDOCW)</em>, 1–10. <a href="https://doi.org/10.1109/EDOCW.2016.7584353">https://doi.org/10.1109/EDOCW.2016.7584353</a>.
</div>
<div id="ref-li:ServiceMesh" class="csl-entry" role="doc-biblioentry">
Li, W., Y. Lemieux, J. Gao, Z. Zhao, and Y. Han. 2019. <span>“Service Mesh: Challenges, State of the Art, and Future Research Opportunities.”</span> In <em>2019 IEEE International Conference on Service-Oriented System Engineering (SOSE)</em>, 122–25. <a href="https://doi.org/10.1109/SOSE.2019.00026">https://doi.org/10.1109/SOSE.2019.00026</a>.
</div>
<div id="ref-montesi:CircuitBreakers" class="csl-entry" role="doc-biblioentry">
Montesi, Fabrizio, and Janine Weber. 2016. <span>“Circuit Breakers, Discovery, and <span>API</span> Gateways in Microservices.”</span> <em>CoRR</em> abs/1609.05830. <a href="http://arxiv.org/abs/1609.05830">http://arxiv.org/abs/1609.05830</a>.
</div>
<div id="ref-naik:SAMLandFIdM" class="csl-entry" role="doc-biblioentry">
Naik, N., and P. Jenkins. 2017. <span>“Securing Digital Identities in the Cloud by Selecting an Apposite Federated Identity Management from <span>SAML</span>, <span>OAuth</span> and <span>OpenID</span> Connect.”</span> In <em>2017 11th International Conference on Research Challenges in Information Science (RCIS)</em>, 163–74. <a href="https://doi.org/10.1109/RCIS.2017.7956534">https://doi.org/10.1109/RCIS.2017.7956534</a>.
</div>
<div id="ref-RFC7617" class="csl-entry" role="doc-biblioentry">
Reschke, Julian. 2015. <span>“The ’Basic’ <span>HTTP</span> Authentication Scheme.”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc7617">https://tools.ietf.org/html/rfc7617</a>.
</div>
<div id="ref-spec:OIDC" class="csl-entry" role="doc-biblioentry">
Sakimura, Natsuhiko, John Bradley, Mike Jones, Breno De Medeiros, and Chuck Mortimore. 2014. <span>“Openid Connect Core 1.0.”</span> Spec. The <span>OpenID</span> Foundation <span>OIDF</span>. <a href="https://openid.net/specs/openid-connect-core-1_0.html">https://openid.net/specs/openid-connect-core-1_0.html</a>.
</div>
</div>
<h1 class="unnumbered" id="appendix-a-installation-guide-for-poc">Appendix A: Installation Guide for PoC</h1>
<blockquote>
<p>TODO</p>
</blockquote>
<h1 class="unnumbered" id="appendix-b-teaching-material-for-kubernetes-operators">Appendix B: Teaching Material for Kubernetes Operators</h1>
<blockquote>
<p>TODO</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>According to the matrix problem: <span class="math inline"><em>X</em> services * <em>Y</em> authentication methods</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://kubernetes.io/" class="uri">https://kubernetes.io/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://www.envoyproxy.io/" class="uri">https://www.envoyproxy.io/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://www.getambassador.io/" class="uri">https://www.getambassador.io/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://github.com/prometheus-operator/prometheus-operator" class="uri">https://github.com/prometheus-operator/prometheus-operator</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://github.com/zalando/postgres-operator" class="uri">https://github.com/zalando/postgres-operator</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="https://github.com/GoogleCloudPlatform/cloudsql-proxy" class="uri">https://github.com/GoogleCloudPlatform/cloudsql-proxy</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="https://istio.io/" class="uri">https://istio.io/</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p> <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/ext_authz_filter" class="uri">https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/ext_authz_filter</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Opaque OIDC Token of an IDP.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p><a href="https://github.com/buehler/dotnet-operator-sdk" class="uri">https://github.com/buehler/dotnet-operator-sdk</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p><a href="https://zitadel.ch" class="uri">https://zitadel.ch</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>In the example it is https://kubernetes.docker.internal since this is the local configured URL for “Docker Desktop”<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p> <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/" class="uri">https://docs.microsoft.com/en-us/aspnet/core/razor-pages/</a><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>

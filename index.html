<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christoph Bühler" />
  <meta name="keywords" content="Authentication, Distributed, Trust, Microservices, Kubernetes" />
  <title>Distributed Authentication Mesh</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Distributed Authentication Mesh</h1>
<p class="subtitle">Declarative Adhoc Conversion of Credentials</p>
<p class="author">Christoph Bühler</p>
<p class="date"><p>Spring Semester 2021<br />
University of Applied Science of Eastern Switzerland (OST)</p></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#definitions-and-boundaries">Definitions and Boundaries</a>
<ul>
<li><a href="#context">Context</a></li>
<li><a href="#kubernetes">Kubernetes</a>
<ul>
<li><a href="#what-is-kubernetes">What is Kubernetes</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#sec:kubernetes_operator">Operator</a></li>
<li><a href="#sec:kubernetes_sidecar">Sidecar</a></li>
<li><a href="#service-mesh">Service Mesh</a></li>
</ul></li>
<li><a href="#authentication-and-authorization">Authentication and Authorization</a>
<ul>
<li><a href="#basic">Basic</a></li>
<li><a href="#sec:auth_oidc">OpenID Connect (OIDC)</a></li>
</ul></li>
</ul></li>
<li><a href="#state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</a>
<ul>
<li><a href="#state-of-the-art">State of the Art</a></li>
<li><a href="#deficiencies">Deficiencies</a></li>
</ul></li>
<li><a href="#further-work">Further work</a></li>
<li><a href="#grober-roter-faden-projektbericht">Grober Roter Faden Projektbericht</a></li>
<li><a href="#todos">Todos</a></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Modern cloud environments solve many problems like the discovery of services and data transfer or communiation between services in general. One modern way of solving service discovery and communication is a Service Mesh, which introduces an additional infrastructure layer that manages the communication between services <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>.</p>
<p>However, a specific problem is not solved yet: “dynamic” trusted communication between services. When a service, that is capable of handling OpenID Connect (OIDC) credentials, wants to communicate with a service that only knows Basic Authentication that originating service must implement some sort of conversion or know static credentials to communicate with the basic auth service. Generally, this introduces changes to the software of services. In small applications which consist of one or two services, implementing this conversion may be a feasable option. If we look at an application which spans over a big landscape and a multitude of services, implementing each and every possible authentication mechanism and the according conversions will be error prone work and does not scale well<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>The goal of the project “Distributed Authentication Mesh” is to provide a solution for this problem.</p>
<blockquote>
<p>TODO.</p>
</blockquote>
<h1 id="definitions-and-boundaries">Definitions and Boundaries</h1>
<p>This section provides general information about the project, the context and prerequisite knowledge. It gives an overview of the context as well as terminology and general definitions.</p>
<h2 id="context">Context</h2>
<p>This project aims at the specific problem of declarative conversion of credentials to ensure authorized communication between services. The solution may be runnable on various platforms but will be implemented according to Kubernetes standards. Kubernetes<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is an orchestration platform that works with containerized applications. The solution introduces an operator pattern, as explained in Section <a href="#sec:kubernetes_operator">2.2.3</a></p>
<p>The deliverables of this and further projects may aid services to communicate with each other despite different authentication mechanisms. As an example, this could be used to enable a modern web application that uses OpenID Connect (OIDC) as the authentication and authorization mechanism to communicate with a legacy application that was deployed on the Kubernetes cluster but not yet rewritten. This transformation of credentials (from OIDC to Basic Auth) is done by the solution of the projects instead of manual work which may introduc code changes to either service.</p>
<p>This specific project provides a proof of concept (PoC) with an initial version on a GitHub repository. The PoC demonstrates that it is possible to instruct an Envoy<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> proxy to communicate with an injected service to modify authentication credentials in-flight.</p>
<p>To use the proposed solution of this project, no service mesh or other complex layer is needed. The solution runs without those additional parts on a Kubernetes cluster. To provide service discovery, the default internal DNS capabilities of Kubernetes are sufficient.</p>
<h2 id="kubernetes">Kubernetes</h2>
<h3 id="what-is-kubernetes">What is Kubernetes</h3>
<p>Kubernetes is an open source platform that manages containerized workloads and applications. Workloads may be accessed via “Services” that use a DNS naming system. Kubernetes uses declarative definitions to compare the actual state of the system with the expected state <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<div id="fig:kubernetes_container_evolution" class="fignos">
<figure>
<img src="images/Kubernetes/Container_Evolution.png" data-short-caption="Kubernetes Container Evolution" alt="Figure 1: Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes (CNCF 2021). This image is licensed under the CC BY 4.0 license (Creative Commons 2021)." /><figcaption aria-hidden="true"><span>Figure 1:</span> Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>. This image is licensed under the CC BY 4.0 license <span class="citation" data-cites="cc:CCBY4.0">(Creative Commons 2021)</span>.</figcaption>
</figure>
</div>
<p>According to the Kubernetes team, the way of deploying applications has evolved. As shown in Figure <a href="#fig:kubernetes_container_evolution">1</a>, the “Traditional Era” was the time, when applications were deployed via FTP access and started manually (e.g. on an Apache webserver). Then the revolution to virtual machines came and technologies that could virtualize a whole operating system, such as VMWare, were born. The latest stage, “Container Era,” defines a new way deploying workloads by virtualizing processes instead of operating systems and therefore better use the given resources <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<p>Kubernetes is a major player in “Container Deployment” as seen in Figure <a href="#fig:kubernetes_container_evolution">1</a> and supports teams with the following features according to the documentation <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>:</p>
<ul>
<li><strong>Service discovery and load balancing</strong>: Use DNS names or IP addresses to route traffic to a container and if the traffic is high and multiple instances are available, Kubernetes does load balance the traffic</li>
<li><strong>Storage orchestration</strong>: Automatically provide storage in the form of mountable volumes</li>
<li><strong>Automated rollouts and rollbacks</strong>: When a new desired state is provided Kubernetes tries to achieve the state at a controlled rate and has the possibility of performing rollbacks</li>
<li><strong>Automatec bin packing</strong>: Kubernetes only needs to know how much CPU and RAM a workload needs and then takes care of placing the workload on a fitting node in the cluster</li>
<li><strong>Self-healing</strong>: If workloads are failing, Kubernetes tries to restart the applications and even kills services that do not respond to the configured health checks</li>
<li><strong>Secret and configuration management</strong>: Kubernetes has a store for sensitive data as well as configurational data that may change the behaviour of a workload</li>
</ul>
<p>The list of features is not complete. There are many concepts in Kubernetes which help to build complex deployment scenarios and enable teams to ship their applications in an agile manner.</p>
<h3 id="terminology">Terminology</h3>
<p>Find the common Kubernetes terminology attached in Table <a href="#tbl:kubernetes_terminology">1</a>. The table provides a list of terms that will be used to explain concepts like the operator pattern in Section <a href="#sec:kubernetes_operator">2.2.3</a>.</p>
<div id="tbl:kubernetes_terminology" class="tablenos">
<table id="tbl:kubernetes_terminology" style="width:92%;">
<caption><span>Table 1:</span> Common Kubernetes Terminology </caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Container</td>
<td>Smallest possible unit in a deployment. Contains the definition of the workload. A container consists of a container image, arguments, volumes and other specific information to carry out a task.</td>
</tr>
<tr class="even">
<td>Pod</td>
<td>Composed of multiple containers. Is ran by kubernetes as an instance of a deployment. Pods may be scaled according to definitions or “pod scalers.” Highly coupled tasks are deployed together in a pod (i.e. multiple coupled containers in a pod).</td>
</tr>
<tr class="odd">
<td>Deployment</td>
<td>A deployment is a managed instance of a pod. Kubernetes will run the described pod with the desired replica count on the best possible worker node. Deployments may be scaled with auto-scaling mechanisms.</td>
</tr>
<tr class="even">
<td>Service</td>
<td>A service enables communciation with one or multiple pods. The service contains a selector that points to a certain number of pods and then ensures that the pods are accessable via a DNS name. The name is typically a combination of the servicename and the namespace (e.g. <code>my-service.namespace</code>).</td>
</tr>
<tr class="odd">
<td>Resource</td>
<td>A resource is something that can be managed by Kubernetes. It defines an API endpoint on the master node and allows Kubernetes to store a collection of such API objects. Examples are: <code>Deployment</code>, <code>Service</code> and <code>Pod</code>, to name a few of the built-in resources.</td>
</tr>
<tr class="even">
<td>CRD</td>
<td>A Custom Resource Definition (CRD) enables developers to extend the default Kubernetes API. With a CRD, it is possible to create own resources which creates an API endpoint on the Kubernetes API. An example of such a CRD is the <code>Mapping</code> resource of Ambassador<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</td>
</tr>
<tr class="odd">
<td>Operator</td>
<td>An operator is a software that manages Kubernetes resources and their lifecycle. Operators may use CRDs to define custom objects on which they react when some event (<code>Added</code>, <code>Modified</code> or <code>Deleted</code>) triggers on a resource. For a more in-depth description, see Section <a href="#sec:kubernetes_operator">2.2.3</a>.</td>
</tr>
<tr class="even">
<td>Watcher</td>
<td>A watcher is a constant connection from a client to the Kubernetes API. The watcher defines some search and filter parameters and receives events for the found resources.</td>
</tr>
<tr class="odd">
<td>Validator</td>
<td>A validator is a service that may reject the creation, modification or deletion of resources.</td>
</tr>
<tr class="even">
<td>Mutator</td>
<td>Mutators are called before Kubernetes validates and stores a resource. Mutators may return JSON patches <span class="citation" data-cites="bryan:JSONPatch">(Bryan and Nottingham 2013)</span> to instruct Kubernetes to modify a resource prior to validating and storing them.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="sec:kubernetes_operator">Operator</h3>
<p>An operator in Kubernetes is an extension to the Kubernetes API itself. A custom operator typically manages the whole lifecycle of an appliction it manages <span class="citation" data-cites="dobies:KubernetesOperators">(Dobies and Wood 2020)</span>. Such a custom operator can further be used to reconcile normal Kubernetes resources or any combination thereof.</p>
<p>Some examples of application operators are:</p>
<ul>
<li>Prometheus Operator<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>: Manages instances of Prometheus in a cluster</li>
<li>Postgres Operator<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>: Manages PostgreSQL clusters inside Kubernetes, with the support of multiple instance database clusters</li>
</ul>
<p>There exists a broad list of operators, which can be (partially) viewed on <a href="https://operatorhub.io/">operatorhub.io</a>.</p>
<div id="fig:kubernetes_operator_workflow" class="fignos">
<figure>
<img src="diagrams/sequences/bc6f3409edb67939f5539cb0ada59de7.png" alt="Figure 2: Kubernetes Operator Workflow" /><figcaption aria-hidden="true"><span>Figure 2:</span> Kubernetes Operator Workflow</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:kubernetes_operator_workflow">2</a> shows the general workflow of an event that is managed by an operator. When an operator is installed and running on a Kubernetes cluster, it registers “Resource Watchers” with the API and receives notifications when the master node modifies resources a watched resource. The overviewed events are “Added,” “Modified” and “Deleted.” There are two additional events that may be returned by the API (“Error” and “Bookmark”) but they are typically not needed in an operator.</p>
<p>When the user interacts with the Kubernetes API (for example via the <code>kubectl</code> executable) and creates a new instance of a resource, the API will first call any “Mutator” in a serial manner. After the mutators, the API will call any “Validators” in parallel and if no validator objects against the creation, the API will then store the resource and tries to apply the transition for the new desired state. Now, the operator receives the notification about the watched resource and may interact with the event. Such an action may include to update resources, create more resources or even delete other instances.</p>
<h3 id="sec:kubernetes_sidecar">Sidecar</h3>
<p>The sidecar pattern is the most common pattern for multi-container deployments. Sidecars are containers that enhance the functionality of the main container in a pod. An example for such a sidecar is a log collector, that collects log files written to the file system and forwards them towards some log processing software <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, sec. 4.1)</span>. Another example is the Google CloudSQL Proxy<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, which provides access to a CloudSQL instance from a pod without routing the whole traffic through Kubernetes services.</p>
<div id="fig:kubernetes_sidecar" class="fignos">
<figure>
<img src="diagrams/component/e04b0bd0476fb01ac6d4e9a5b2f2a17a.png" data-short-caption="Example of a sidecar container" alt="Figure 3: Sidecar container extending a main container in a pod. As example, this could be a log collector , figure 1(Burns and Oppenheimer 2016, fig. 1)." /><figcaption aria-hidden="true"><span>Figure 3:</span> Sidecar container extending a main container in a pod. As example, this could be a log collector <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, fig. 1)</span>.</figcaption>
</figure>
</div>
<p>The example shown in Figure <a href="#fig:kubernetes_sidecar">3</a> is extensible. Such sidecars may be injected by a mutator or an operator to extend functionality.</p>
<h3 id="service-mesh">Service Mesh</h3>
<p>A “Service Mesh” is a dedicated infrastructure layer that handles intercommunication between services. It is responsible for the delivery of requests in a modern cloud application <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>. An example from the practice is “Istio”<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. When using Istio, the applications do not need to know if there is a service mesh installed or not. Istio will inject a sidecar (see Section <a href="#sec:kubernetes_sidecar">2.2.4</a>) into pods and handle the communication with the injected services.</p>
<p>The service mesh provides a set of features <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>:</p>
<ul>
<li><strong>Service discovery</strong>: The mechanism to locate and communicate with a workload / service. In a cloud environment, the location of services will likely change, thus the service mesh provides a way to access the services in the cloud.</li>
<li><strong>Load balancing</strong>: As an addition to the service discovery, the mesh provides load balancing mechanisms as is done by Kubernetes itself.</li>
<li><strong>Fault tolerance</strong>: The router in a service mesh is responsible to route traffic to healthy services. If a service is unavailable or even reports a crash, traffic should not be routed to this instance.</li>
<li><strong>Traffic monitoring</strong>: In contrast to the default Kubernetes possibilities, with a service mesh, the traffic from and to various services can be monitored in detail. This offers the opportunity to derive reports per target, success rates and other metrics.</li>
<li><strong>Circuit breaking</strong>: The ability to cut off an overloaded service and back off the remaining requests instead of totally failing the service under stress. A circuit breaker pattern measures the failure rate of a service and applies states to the service: “Closed” - requests are passed to the service, “Open” - requests are not passed to this instance, “Half-Open” - only a limited number is passed <span class="citation" data-cites="montesi:CircuitBreakers">(Montesi and Weber 2016, sec. 2)</span>.</li>
<li><strong>Authentication and access control</strong>: Through the control plane, a service mesh may define the rules of communication. It defines which services can communicate with one another.</li>
</ul>
<p>As observed in the list above, many of the features of a service mesh are already provided by Kubernetes. Service discovery, load balancing, fault tolerance and - though limited - traffic monitoring is already possible with Kubernetes. Introducing a service mesh into a cluster enables administrators to build more complex scenarios and deployments.</p>
<h2 id="authentication-and-authorization">Authentication and Authorization</h2>
<h3 id="basic">Basic</h3>
<p>The <code>Basic</code> authentication scheme is a trivial authentication that accepts a username and a password encoded in Base64. To transmit the credentials, a construct with the schematics of <code>&lt;username&gt;:&lt;password&gt;</code> is created and inserted into the http request as the <code>Authorization</code> header with the prefix <code>Basic</code> <span class="citation" data-cites="reschke:BasicAuth">(Reschke 2015, sec. 2)</span>. An example with the username <code>ChristophBuehler</code> and password <code>SuperSecure</code> would result in the following header: <code>Authorization: Basic Q2hyaXN0b3BoQnVlaGxlcjpTdXBlclNlY3VyZQ==</code>.</p>
<h3 id="sec:auth_oidc">OpenID Connect (OIDC)</h3>
<p>OpenID Connect is an authenticating mechanism, that builds upon the <code>OAuth 2.0</code> authorization protocol. OAuth 2.0 deals with authorization only and grants access to data and features on a specific application. OAuth by itself does not define <em>how</em> the credentials are transmitted and exchanged <span class="citation" data-cites="hardt:OAuth2.0Spec">(Hardt and others 2012)</span>. OIDC adds a layer on top of OAuth 2.0 that defines <em>how</em> these credentials must be exchanged. This adds login and profile capabilities to any application that uses OIDC <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014)</span>.</p>
<div id="fig:oidc_code_flow" class="fignos">
<figure>
<img src="diagrams/sequences/b45156f65349258d13a013f27e003332.png" data-short-caption="OIDC code flow" alt="Figure 4: OIDC code authorization flow (Sakimura et al. 2014)." /><figcaption aria-hidden="true"><span>Figure 4:</span> OIDC code authorization flow <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014)</span>.</figcaption>
</figure>
</div>
<p>When a user wants to authenticate himself with OIDC, one of the possible “flows” is the “Authorization Code Flow” <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014, sec. 3.1)</span>. Other possible flows are the “Implicit Flow” <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014, sec. 3.2)</span> and the “Hybrid Flow” <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014, sec. 3.3)</span>. In Figure <a href="#fig:oidc_code_flow">4</a>, the “Authorization Code Flow” is depicted. A user that wants to access a certain resource on a relying party (i.e. something that relies on the information about the user) and is not authenticated and authorized, the relying party forwards the user to the identity provider (IdP). The user provides his credentials to the IdP and is returned to the relying party with an authorization code. The relying party can then exchange the authorization code to valid tokens on the token endpoint of the IdP. Typically, <code>access_token</code> and <code>id_token</code> are provided. While the <code>id_token</code> must be a JSON Web Token (JWT) <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014, sec. 2)</span>, the <code>access_token</code> can be in any format <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014, sec. 3.3.3.8)</span>.</p>
<h1 id="state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</h1>
<p>This section gives an overview over the current state of the art, the practice, as well as the deficiencies according to the author. Furthermore this section states an assessment of the current practice and the solutions found.</p>
<h2 id="state-of-the-art">State of the Art</h2>
<p>In cloud environments, a problem that is well solved is the transmission of data from one point to another. Kubernetes, for example, uses “Services” that provide a DNS name for a specified workload. In terms of authentication and authorization, there exist a variety of schemes that enable an application to authenticate and authorize their users. OpenID Connect (OIDC) (see Section <a href="#sec:auth_oidc">2.3.2</a>) is a modern authentication scheme, that builds upon OAuth 2.0, that in turn handles authorization <span class="citation" data-cites="sakimura:OIDCCore">(Sakimura et al. 2014)</span>.</p>
<p>Modern software architectures that are specifically designed for the cloud are called “Cloud Native Applications” (CNA). <span class="citation" data-cites="kratzke:CloudNativeApplications">Kratzke and Peinl (2016)</span> define a CNA as:</p>
<blockquote>
<p>“A cloud-native application is a distributed, elastic and horizontal scalable system composed of (micro)services which isolates state in a minimum of stateful components. The application and each self-contained deployment unit of that application is designed according to cloud-focused design patterns and operated on a self-service elastic platform.” <span class="citation" data-cites="kratzke:CloudNativeApplications">(Kratzke and Peinl 2016, sec. 3)</span>.</p>
</blockquote>
<p>However, with CNAs and the general movement to cloud environments, not all applications get that chance to adjust. For various reasons like budget, time or complexity, legacy applications and monoliths are not refactored or re-written before they are deployed into a cloud environment. If the legacy applications are mixed with modern systems, then the need of “translation” arises. Assuming, that the modern part is a secure application, that uses OIDC to authorize its users and the application needs to fetch data from the legacy system that does not understand OIDC, code changes must be made. Following the previous assumption, the code changes will likely be introduced into the modern application, since it is better maintainable and deployable than the legacy monolith. Hence, the modern application receives changes that may introduce new bugs or security vulnerabilities.</p>
<div id="fig:is_solution_components" class="fignos">
<figure>
<img src="diagrams/component/227922acac1ebbd8575475cb4e34cc24.png" data-short-caption="Microservice Architecture with legacy components" alt="Figure 5: Microservice Architecture that contains modern applications as well as legacy services." /><figcaption aria-hidden="true"><span>Figure 5:</span> Microservice Architecture that contains modern applications as well as legacy services.</figcaption>
</figure>
</div>
<p>We consider the components in Figure <a href="#fig:is_solution_components">5</a>:</p>
<ul>
<li><strong>User</strong>: A person with access to the application</li>
<li><strong>Client</strong>: A modern single page application (SPA)</li>
<li><strong>IAM</strong>: Identity Provider for the solution (does not necessarily reside in the same cloud)</li>
<li><strong>Service A</strong>: A modern API application and primary access point for the client</li>
<li><strong>Service B</strong>: Legacy service that is called by service a to fetch some additional data</li>
</ul>
<p>The stated scenario is quite common. Legacy services may not be the primary use-case, but there exist other reasons to have the need of using TODO</p>
<div id="fig:is_solution_process" class="fignos">
<figure>
<img src="diagrams/sequences/abf568f8e377caa7c2c463d28331ee60.png" data-short-caption="Current process of legacy communication" alt="Figure 6: Current state of the art of accessing legacy systems from modern services with differing authentication schemes." /><figcaption aria-hidden="true"><span>Figure 6:</span> Current state of the art of accessing legacy systems from modern services with differing authentication schemes.</figcaption>
</figure>
</div>
<p>The process in Figure <a href="#fig:is_solution_process">6</a> shows such a describe scenario. In Figure <a href="#fig:is_solution_process">6</a>, the “client” is a single page application (SPA), that authenticates against an arbitrary Identity and Access Management System (IAM). “Service A”</p>
<p>TODO: describe the process better</p>
<h2 id="deficiencies">Deficiencies</h2>
<p>asdf</p>
<h1 id="further-work">Further work</h1>
<ul>
<li>create common domain model for user</li>
<li>use this domain language model to translate credentials from and to a specific implementation</li>
<li>use JWT to harden these credentials (signing)</li>
<li>operator must create and deliver keys</li>
<li>operator must have set of public keys</li>
</ul>
<h1 id="grober-roter-faden-projektbericht">Grober Roter Faden Projektbericht</h1>
<ol type="1">
<li>Introduction
<ul>
<li>Das Erreichte und den Überblick der Arbeit wiedergeben</li>
<li>Erklären wie die Arbeit aufgebaut ist und welche Details wo zu finden sind</li>
</ul></li>
<li>Einführung ins Thema
<ul>
<li>Leser ausbilden</li>
<li>Backgroundinformationen liefern</li>
<li>Context der Arbeit</li>
<li>Begrifflichkeiten erklären</li>
</ul></li>
<li>IST / SOLL Beschreibung
<ul>
<li>Was gibt es</li>
<li>Wie arbeit die Leute</li>
<li>Wo sind die Defizite</li>
</ul></li>
<li>Wie lösen wir die Probleme
<ul>
<li>Planung der Software (Diagramme etc.)</li>
<li>Wie die Lösung aussieht</li>
<li>Umsetzung der Konzepte</li>
</ul></li>
<li>Nachweis
<ul>
<li>Beweis anführen, dass das vorgeschlagene Konzept funktioniert</li>
<li>Beispiele nutzen um Leute abzuholen</li>
</ul></li>
<li>Conclusion
<ul>
<li>Ausblick (Referenz auf weitere Projektarbeit)</li>
<li>Was man gemacht hat (klassischer Paperdiamant)</li>
</ul></li>
</ol>
<h1 id="todos">Todos</h1>
<p>Following the description of the current situation, a definition of the should situation gives an overview of the purposed solution.</p>
<ul>
<li>Describe the IS situation.</li>
<li>Describe the SHOULD situation.</li>
<li>describe service mesh (image from referecne could be used)</li>
</ul>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-bryan:JSONPatch" class="csl-entry" role="doc-biblioentry">
Bryan, Paul, and Mark Nottingham. 2013. <span>“Javascript Object Notation (Json) Patch.”</span> <em>RFC 6902 (Proposed Standard)</em>.
</div>
<div id="ref-burns:DesignPatternsForContainerSystems" class="csl-entry" role="doc-biblioentry">
Burns, Brendan, and David Oppenheimer. 2016. <span>“Design Patterns for Container-Based Distributed Systems.”</span> In <em>8th <span>USENIX</span> Workshop on Hot Topics in Cloud Computing (HotCloud 16)</em>. Denver, CO: <span>USENIX</span> Association. <a href="https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns">https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns</a>.
</div>
<div id="ref-github:kubernetesWebsite" class="csl-entry" role="doc-biblioentry">
CNCF. 2021. <span>“Kubernetes Website.”</span> <em>GitHub Repository</em>. <a href="https://github.com/kubernetes/website">https://github.com/kubernetes/website</a>; GitHub.
</div>
<div id="ref-cc:CCBY4.0" class="csl-entry" role="doc-biblioentry">
Creative Commons. 2021. <span>“Attribution 4.0 International (CC BY 4.0).”</span> <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>.
</div>
<div id="ref-dobies:KubernetesOperators" class="csl-entry" role="doc-biblioentry">
Dobies, Jason, and Joshua Wood. 2020. <em>Kubernetes Operators: Automating the Container Orchestration Platform</em>. " O’Reilly Media, Inc.".
</div>
<div id="ref-hardt:OAuth2.0Spec" class="csl-entry" role="doc-biblioentry">
Hardt, Dick, and others. 2012. <span>“The OAuth 2.0 Authorization Framework.”</span> RFC 6749, October.
</div>
<div id="ref-kratzke:CloudNativeApplications" class="csl-entry" role="doc-biblioentry">
Kratzke, N., and R. Peinl. 2016. <span>“ClouNS - a Cloud-Native Application Reference Model for Enterprise Architects.”</span> In <em>2016 IEEE 20th International Enterprise Distributed Object Computing Workshop (EDOCW)</em>, 1–10. <a href="https://doi.org/10.1109/EDOCW.2016.7584353">https://doi.org/10.1109/EDOCW.2016.7584353</a>.
</div>
<div id="ref-li:ServiceMesh" class="csl-entry" role="doc-biblioentry">
Li, W., Y. Lemieux, J. Gao, Z. Zhao, and Y. Han. 2019. <span>“Service Mesh: Challenges, State of the Art, and Future Research Opportunities.”</span> In <em>2019 IEEE International Conference on Service-Oriented System Engineering (SOSE)</em>, 122–25. <a href="https://doi.org/10.1109/SOSE.2019.00026">https://doi.org/10.1109/SOSE.2019.00026</a>.
</div>
<div id="ref-montesi:CircuitBreakers" class="csl-entry" role="doc-biblioentry">
Montesi, Fabrizio, and Janine Weber. 2016. <span>“Circuit Breakers, Discovery, and <span>API</span> Gateways in Microservices.”</span> <em>CoRR</em> abs/1609.05830. <a href="http://arxiv.org/abs/1609.05830">http://arxiv.org/abs/1609.05830</a>.
</div>
<div id="ref-reschke:BasicAuth" class="csl-entry" role="doc-biblioentry">
Reschke, Julian. 2015. <span>“The’basic’http Authentication Scheme.”</span> <em>Work in Progress, Draft-Ietf-Httpauth-Basicauth-Update-07</em>.
</div>
<div id="ref-sakimura:OIDCCore" class="csl-entry" role="doc-biblioentry">
Sakimura, Natsuhiko, John Bradley, Mike Jones, Breno De Medeiros, and Chuck Mortimore. 2014. <span>“Openid Connect Core 1.0.”</span> <em>The OpenID Foundation</em>, S3.
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>According to the matrix problem: <span class="math inline"><em>X</em> services * <em>Y</em> authentication methods</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://kubernetes.io/" class="uri">https://kubernetes.io/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://www.envoyproxy.io/" class="uri">https://www.envoyproxy.io/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://www.getambassador.io/" class="uri">https://www.getambassador.io/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://github.com/prometheus-operator/prometheus-operator" class="uri">https://github.com/prometheus-operator/prometheus-operator</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://github.com/zalando/postgres-operator" class="uri">https://github.com/zalando/postgres-operator</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="https://github.com/GoogleCloudPlatform/cloudsql-proxy" class="uri">https://github.com/GoogleCloudPlatform/cloudsql-proxy</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="https://istio.io/" class="uri">https://istio.io/</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>

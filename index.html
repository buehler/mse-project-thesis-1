<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christoph Bühler1" />
  <meta name="keywords" content="Authentication, Distributed, Trust, Microservices, Kubernetes" />
  <title>Distributed Authentication Mesh</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Distributed Authentication Mesh</h1>
<p class="subtitle">Declarative Adhoc Conversion of Credentials</p>
<p class="author">Christoph Bühler<sup>1</sup></p>
<p class="date">Spring Semester 2021</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#definitions-and-boundaries">Definitions and Boundaries</a>
<ul>
<li><a href="#context">Context</a></li>
<li><a href="#kubernetes">Kubernetes</a>
<ul>
<li><a href="#what-is-kubernetes">What is Kubernetes</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#sec:kubernetes_operator">Operator</a></li>
<li><a href="#sec:kubernetes_sidecar">Sidecar</a></li>
<li><a href="#service-mesh">Service Mesh</a></li>
</ul></li>
<li><a href="#authentication-and-authorization">Authentication and Authorization</a>
<ul>
<li><a href="#basic">Basic</a></li>
<li><a href="#openid-connect-oidc">OpenID Connect (OIDC)</a></li>
</ul></li>
</ul></li>
<li><a href="#state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</a></li>
<li><a href="#grober-roter-faden-projektbericht">Grober Roter Faden Projektbericht</a></li>
<li><a href="#todos">Todos</a></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<p><sup>1</sup> University of Applied Science of Eastern Switzerland (OST)</p>
<h1 id="introduction">Introduction</h1>
<p>Modern cloud environments solve many problems like the discovery of services and data transfer or communiation between services in general. One modern way of solving service discovery and communication is a Service Mesh, which introduces an additional infrastructure layer that manages the communication between services <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>.</p>
<p>However, a specific problem is not solved yet: “dynamic” trusted communication between services. When a service, that is capable of handling OpenID Connect (OIDC) credentials, wants to communicate with a service that only knows Basic Authentication that originating service must implement some sort of conversion or know static credentials to communicate with the basic auth service. Generally, this introduces changes to the software of services. In small applications which consist of one or two services, implementing this conversion may be a feasable option. If we look at an application which spans over a big landscape and a multitude of services, implementing each and every possible authentication mechanism and the according conversions will be error prone work and does not scale well<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>The goal of the project “Distributed Authentication Mesh” is to provide a solution for this problem.</p>
<blockquote>
<p>TODO.</p>
</blockquote>
<h1 id="definitions-and-boundaries">Definitions and Boundaries</h1>
<p>This section provides general information about the project, the context and prerequisite knowledge. It gives an overview of the context as well as terminology and general definitions.</p>
<h2 id="context">Context</h2>
<p>This project aims at the specific problem of declarative conversion of credentials to ensure authorized communication between services. The solution may be runnable on various platforms but will be implemented according to Kubernetes standards. Kubernetes<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is an orchestration platform that works with containerized applications. The solution introduces an operator pattern, as explained in Section <a href="#sec:kubernetes_operator">2.2.3</a></p>
<p>The deliverables of this project may aid services to communicate with each other despite different authentication mechanisms. As an example, this could be used to enable a modern web application that uses OpenID Connect (OIDC) as the authentication and authorization mechanism to communicate with a legacy application that was deployed on the Kubernetes cluster but not yet rewritten. This transformation of credentials (from OIDC to Basic Auth) is done by the solution of this project instead of manual work which may introduc code changes to either service.</p>
<p>To use the proposed solution of this project, no service mesh or other complex layer is needed. The solution runs without those additional parts on a Kubernetes cluster. To provide service discovery, the default internal DNS capabilities of Kubernetes are sufficient.</p>
<h2 id="kubernetes">Kubernetes</h2>
<h3 id="what-is-kubernetes">What is Kubernetes</h3>
<p>Kubernetes is an open source platform that manages containerized workloads and applications. Workloads may be accessed via “Services” that use a DNS naming system. Kubernetes uses declarative definitions to compare the actual state of the system with the expected state <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<div id="fig:kubernetes_container_evolution" class="fignos">
<figure>
<img src="images/Kubernetes/Container_Evolution.png" data-short-caption="Kubernetes Container Evolution" alt="Figure 1: Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes (CNCF 2021). This image is licensed under the CC BY 4.0 license (Creative Commons 2021)." /><figcaption aria-hidden="true"><span>Figure 1:</span> Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>. This image is licensed under the CC BY 4.0 license <span class="citation" data-cites="cc:CCBY4.0">(Creative Commons 2021)</span>.</figcaption>
</figure>
</div>
<p>According to the Kubernetes team, the way of deploying applications has evolved. As shown in Figure <a href="#fig:kubernetes_container_evolution">1</a>, the “Traditional Era” was the time, when applications were deployed via FTP access and started manually (e.g. on an Apache webserver). Then the revolution to virtual machines came and technologies that could virtualize a whole operating system, such as VMWare, were born. The latest stage, “Container Era,” defines a new way deploying workloads by virtualizing processes instead of operating systems and therefore better use the given resources <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<p>Kubernetes is a major player in “Container Deployment” as seen in Figure <a href="#fig:kubernetes_container_evolution">1</a> and supports teams with the following features according to the documentation <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>:</p>
<ul>
<li><strong>Service discovery and load balancing</strong>: Use DNS names or IP addresses to route traffic to a container and if the traffic is high and multiple instances are available, Kubernetes does load balance the traffic</li>
<li><strong>Storage orchestration</strong>: Automatically provide storage in the form of mountable volumes</li>
<li><strong>Automated rollouts and rollbacks</strong>: When a new desired state is provided Kubernetes tries to achieve the state at a controlled rate and has the possibility of performing rollbacks</li>
<li><strong>Automatec bin packing</strong>: Kubernetes only needs to know how much CPU and RAM a workload needs and then takes care of placing the workload on a fitting node in the cluster</li>
<li><strong>Self-healing</strong>: If workloads are failing, Kubernetes tries to restart the applications and even kills services that do not respond to the configured health checks</li>
<li><strong>Secret and configuration management</strong>: Kubernetes has a store for sensitive data as well as configurational data that may change the behaviour of a workload</li>
</ul>
<h3 id="terminology">Terminology</h3>
<blockquote>
<p>TODO, make fancy (table is not nice)</p>
</blockquote>
<p>Find the common Kubernetes terminology attached in Table <a href="#tbl:kubernetes_terminology">1</a>. The table provides a list of terms that will be used to explain concepts like the operator pattern in Section <a href="#sec:kubernetes_operator">2.2.3</a>.</p>
<div id="tbl:kubernetes_terminology" class="tablenos">
<table id="tbl:kubernetes_terminology">
<caption><span>Table 1:</span> Common Kubernetes Terminology </caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Object</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Container</td>
<td>Smallest possible unit in a deployment. Contains a workload and runs with a docker image</td>
</tr>
<tr class="even">
<td>Pod</td>
<td>Composed of multiple containers. Is ran by kubernetes as an “application” or “workload”</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Deployment</li>
<li>Watcher</li>
<li>Service</li>
<li>Resource</li>
<li>CRD</li>
<li>Validator</li>
<li>Mutator</li>
<li>Data Plane</li>
<li>Control Plane</li>
</ul>
<h3 id="sec:kubernetes_operator">Operator</h3>
<p>An operator in Kubernetes is an extension to the Kubernetes API itself. A custom operator typically manages the whole lifecycle of an appliction it manages <span class="citation" data-cites="dobies:KubernetesOperators">(Dobies and Wood 2020)</span>. Such a custom operator can further be used to reconcile normal Kubernetes resources or any combination thereof.</p>
<p>Some examples of application operators are:</p>
<ul>
<li>Prometheus Operator<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>: Manages instances of Prometheus in a cluster</li>
<li>Postgres Operator<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>: Manages PostgreSQL clusters inside Kubernetes, with the support of multiple instance database clusters</li>
</ul>
<p>There exists a broad list of operators, which can be (partially) viewed on <a href="https://operatorhub.io/">operatorhub.io</a>.</p>
<div id="fig:kubernetes_operator_workflow" class="fignos">
<figure>
<img src="diagrams/sequences/bc6f3409edb67939f5539cb0ada59de7.png" alt="Figure 2: Kubernetes Operator Workflow" /><figcaption aria-hidden="true"><span>Figure 2:</span> Kubernetes Operator Workflow</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:kubernetes_operator_workflow">2</a> shows the general workflow of an event that is managed by an operator. When an operator is installed and running on a Kubernetes cluster, it registers “Resource Watchers” with the API and receives notifications when the master node modifies resources a watched resource. The overviewed events are “Added,” “Modified” and “Deleted.” There are two additional events that may be returned by the API (“Error” and “Bookmark”) but they are typically not needed in an operator.</p>
<p>When the user interacts with the Kubernetes API (for example via the <code>kubectl</code> executable) and creates a new instance of a resource, the API will first call any “Mutator” in a serial manner. After the mutators, the API will call any “Validators” in parallel and if no validator objects against the creation, the API will then store the resource and tries to apply the transition for the new desired state. Now, the operator receives the notification about the watched resource and may interact with the event. Such an action may include to update resources, create more resources or even delete other instances.</p>
<h3 id="sec:kubernetes_sidecar">Sidecar</h3>
<p>The sidecar pattern is the most common pattern for multi-container deployments. Sidecars are containers that enhance the functionality of the main container in a pod. An example for such a sidecar is a log collector, that collects log files written to the file system and forwards them to some log processing software <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, sec. 4.1)</span>. Another example is the Google CloudSQL Proxy<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, which provides access to a CloudSQL instance from a pod without routing the whole traffic through Kubernetes services.</p>
<div id="fig:kubernetes_sidecar" class="fignos">
<figure>
<img src="diagrams/component/e04b0bd0476fb01ac6d4e9a5b2f2a17a.png" data-short-caption="Example of a sidecar container" alt="Figure 3: Sidecar container extending a main container in a pod. As example, this could be a log collector , figure 1(Burns and Oppenheimer 2016, fig. 1)." /><figcaption aria-hidden="true"><span>Figure 3:</span> Sidecar container extending a main container in a pod. As example, this could be a log collector <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, fig. 1)</span>.</figcaption>
</figure>
</div>
<p>The example shown in Figure <a href="#fig:kubernetes_sidecar">3</a> is extensible. Such sidecars may be injected by a mutator or an operator to extend functionality.</p>
<h3 id="service-mesh">Service Mesh</h3>
<p>A “Service Mesh” is a dedicated infrastructure layer that handles intercommunication between services. It is responsible for the delivery of requests in a modern cloud application <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>. An example from the practice is “Istio”<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. When using Istio, the applications do not need to know if there is a service mesh installed or not. Istio will inject a sidecar (see Section <a href="#sec:kubernetes_sidecar">2.2.4</a>) into pods and handle the communication with the injected services.</p>
<p>The service mesh provides a set of features <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>:</p>
<ul>
<li><strong>Service discovery</strong>: The mechanism to locate and communicate with a workload / service. In a cloud environment, the location of services will likely change, thus the service mesh provides a way to access the services in the cloud.</li>
<li><strong>Load balancing</strong>: As an addition to the service discovery, the mesh provides load balancing mechanisms as is done by Kubernetes itself.</li>
<li><strong>Fault tolerance</strong>: The router in a service mesh is responsible to route traffic to healthy services. If a service is unavailable or even reports a crash, traffic should not be routed to this instance.</li>
<li><strong>Traffic monitoring</strong>: In contrast to the default Kubernetes possibilities, with a service mesh, the traffic from and to various services can be monitored in detail. This offers the opportunity to derive reports per target, success rates and other metrics.</li>
<li><strong>Circuit breaking</strong>: The ability to cut off an overloaded service and back off the remaining requests instead of totally failing the service under stress. A circuit breaker pattern measures the failure rate of a service and applies states to the service: “Closed” - requests are passed to the service, “Open” - requests are not passed to this instance, “Half-Open” - only a limited number is passed <span class="citation" data-cites="montesi:CircuitBreakers">(Montesi and Weber 2016, sec. 2)</span>.</li>
<li><strong>Authentication and access control</strong>: Through the control plane, a service mesh may define the rules of communication. It defines which services can communicate with one another.</li>
</ul>
<p>As observed in the list above, many of the features of a service mesh are already provided by Kubernetes. Service discovery, load balancing, fault tolerance and - though limited - traffic monitoring is already possible with Kubernetes. Introducing a service mesh into a cluster enables administrators to build more complex scenarios and deployments.</p>
<h2 id="authentication-and-authorization">Authentication and Authorization</h2>
<h3 id="basic">Basic</h3>
<p>briefly describe basic auth.</p>
<h3 id="openid-connect-oidc">OpenID Connect (OIDC)</h3>
<p>briefly describe OIDC</p>
<h1 id="state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</h1>
<p>This section gives an overview over the current state of the art as well as the deficiencies according to the author. Following the description of the current situation, a definition of the should situation gives an overview of the purposed solution.</p>
<ul>
<li>Describe the IS situation.</li>
<li>Describe the SHOULD situation.</li>
<li>describe service mesh (image from referecne could be used)</li>
</ul>
<p>Test:</p>
<div id="fig:diagram_test" class="fignos">
<figure>
<img src="diagrams/sequences/abf568f8e377caa7c2c463d28331ee60.png" alt="Figure 4: Diagram Test" /><figcaption aria-hidden="true"><span>Figure 4:</span> Diagram Test</figcaption>
</figure>
</div>
<p>This Figure <a href="#fig:diagram_test">4</a> shows a test.</p>
<h1 id="grober-roter-faden-projektbericht">Grober Roter Faden Projektbericht</h1>
<ol type="1">
<li>Introduction
<ul>
<li>Das Erreichte und den Überblick der Arbeit wiedergeben</li>
<li>Erklären wie die Arbeit aufgebaut ist und welche Details wo zu finden sind</li>
</ul></li>
<li>Einführung ins Thema
<ul>
<li>Leser ausbilden</li>
<li>Backgroundinformationen liefern</li>
<li>Context der Arbeit</li>
<li>Begrifflichkeiten erklären</li>
</ul></li>
<li>IST / SOLL Beschreibung
<ul>
<li>Was gibt es</li>
<li>Wie arbeit die Leute</li>
<li>Wo sind die Defizite</li>
</ul></li>
<li>Wie lösen wir die Probleme
<ul>
<li>Planung der Software (Diagramme etc.)</li>
<li>Wie die Lösung aussieht</li>
<li>Umsetzung der Konzepte</li>
</ul></li>
<li>Nachweis
<ul>
<li>Beweis anführen, dass das vorgeschlagene Konzept funktioniert</li>
<li>Beispiele nutzen um Leute abzuholen</li>
</ul></li>
<li>Conclusion
<ul>
<li>Ausblick (Referenz auf weitere Projektarbeit)</li>
<li>Was man gemacht hat (klassischer Paperdiamant)</li>
</ul></li>
</ol>
<h1 id="todos">Todos</h1>
<p>Todos:</p>
<ul>
<li>nope.</li>
</ul>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-burns:DesignPatternsForContainerSystems" class="csl-entry" role="doc-biblioentry">
Burns, Brendan, and David Oppenheimer. 2016. <span>“Design Patterns for Container-Based Distributed Systems.”</span> In <em>8th <span>USENIX</span> Workshop on Hot Topics in Cloud Computing (HotCloud 16)</em>. Denver, CO: <span>USENIX</span> Association. <a href="https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns">https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns</a>.
</div>
<div id="ref-github:kubernetesWebsite" class="csl-entry" role="doc-biblioentry">
CNCF. 2021. <span>“Kubernetes Website.”</span> <em>GitHub Repository</em>. <a href="https://github.com/kubernetes/website">https://github.com/kubernetes/website</a>; GitHub.
</div>
<div id="ref-cc:CCBY4.0" class="csl-entry" role="doc-biblioentry">
Creative Commons. 2021. <span>“Attribution 4.0 International (CC BY 4.0).”</span> <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>.
</div>
<div id="ref-dobies:KubernetesOperators" class="csl-entry" role="doc-biblioentry">
Dobies, Jason, and Joshua Wood. 2020. <em>Kubernetes Operators: Automating the Container Orchestration Platform</em>. " O’Reilly Media, Inc.".
</div>
<div id="ref-li:ServiceMesh" class="csl-entry" role="doc-biblioentry">
Li, W., Y. Lemieux, J. Gao, Z. Zhao, and Y. Han. 2019. <span>“Service Mesh: Challenges, State of the Art, and Future Research Opportunities.”</span> In <em>2019 IEEE International Conference on Service-Oriented System Engineering (SOSE)</em>, 122–25. <a href="https://doi.org/10.1109/SOSE.2019.00026">https://doi.org/10.1109/SOSE.2019.00026</a>.
</div>
<div id="ref-montesi:CircuitBreakers" class="csl-entry" role="doc-biblioentry">
Montesi, Fabrizio, and Janine Weber. 2016. <span>“Circuit Breakers, Discovery, and <span>API</span> Gateways in Microservices.”</span> <em>CoRR</em> abs/1609.05830. <a href="http://arxiv.org/abs/1609.05830">http://arxiv.org/abs/1609.05830</a>.
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>According to the matrix problem: <span class="math inline"><em>X</em> services * <em>Y</em> authentication methods</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://kubernetes.io/" class="uri">https://kubernetes.io/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://github.com/prometheus-operator/prometheus-operator" class="uri">https://github.com/prometheus-operator/prometheus-operator</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://github.com/zalando/postgres-operator" class="uri">https://github.com/zalando/postgres-operator</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://github.com/GoogleCloudPlatform/cloudsql-proxy" class="uri">https://github.com/GoogleCloudPlatform/cloudsql-proxy</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://istio.io/" class="uri">https://istio.io/</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>

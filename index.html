<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christoph Bühler" />
  <meta name="keywords" content="Authentication, Distributed, Trust, Microservices, Kubernetes" />
  <title>Distributed Authentication Mesh</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Distributed Authentication Mesh</h1>
<p class="subtitle">Declarative Adhoc Conversion of Credentials</p>
<p class="author">Christoph Bühler</p>
<p class="date"><p>Spring Semester 2021<br />
University of Applied Science of Eastern Switzerland (OST)</p></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#definitions-and-boundaries">Definitions and Boundaries</a>
<ul>
<li><a href="#context">Context</a></li>
<li><a href="#kubernetes">Kubernetes</a>
<ul>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#sec:kubernetes_operator">Operator</a></li>
<li><a href="#sec:kubernetes_sidecar">Sidecar</a></li>
<li><a href="#sec:service_mesh">Service Mesh</a></li>
</ul></li>
<li><a href="#authentication-and-authorization">Authentication and Authorization</a>
<ul>
<li><a href="#sec:basic_auth">Basic (RFC7617)</a></li>
<li><a href="#sec:auth_oidc">OpenID Connect (OIDC)</a></li>
</ul></li>
</ul></li>
<li><a href="#state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</a>
<ul>
<li><a href="#state-of-the-art">State of the Art</a></li>
<li><a href="#the-practice">The Practice</a></li>
<li><a href="#sec:deficiencies">Deficiencies</a></li>
</ul></li>
<li><a href="#distributed-authentication-mesh">Distributed Authentication Mesh</a>
<ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#non-functional-requirements">Non-Functional Requirements</a></li>
<li><a href="#contrast">Contrast</a>
<ul>
<li><a href="#saml">SAML</a></li>
<li><a href="#sec:ws-deathstar">WS-*</a></li>
</ul></li>
<li><a href="#architecture">Architecture</a>
<ul>
<li><a href="#brief-description">Brief Description</a></li>
<li><a href="#use-case">Use Case</a></li>
<li><a href="#system-architecture">System Architecture</a></li>
<li><a href="#sequences">Sequences</a></li>
<li><a href="#communication">Communication</a></li>
</ul></li>
<li><a href="#implementation-proof-of-concept-poc">Implementation Proof of Concept (PoC)</a>
<ul>
<li><a href="#showcase-application">Showcase Application</a></li>
<li><a href="#envoy-sidecar">Envoy Sidecar</a></li>
<li><a href="#translator">Translator</a></li>
<li><a href="#operator">Operator</a></li>
<li><a href="#poc-composition">PoC Composition</a></li>
</ul></li>
</ul></li>
<li><a href="#evaluation">Evaluation</a></li>
<li><a href="#further-work">Further work</a></li>
<li><a href="#grober-roter-faden-projektbericht">Grober Roter Faden Projektbericht</a></li>
<li><a href="#todos">Todos</a></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Modern cloud environments solve many problems like the discovery of services and data transfer or communiation between services in general. One modern way of solving service discovery and communication is a Service Mesh, which introduces an additional infrastructure layer that manages the communication between services <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>.</p>
<p>However, a specific problem is not solved yet: “dynamic” trusted communication between services. When a service, that is capable of handling OpenID Connect (OIDC) credentials, wants to communicate with a service that only knows Basic Authentication that originating service must implement some sort of conversion or know static credentials to communicate with the basic auth service. Generally, this introduces changes to the software of services. In small applications which consist of one or two services, implementing this conversion may be a feasable option. If we look at an application which spans over a big landscape and a multitude of services, implementing each and every possible authentication mechanism and the according conversions will be error prone work and does not scale well<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>The goal of the project “Distributed Authentication Mesh” is to provide a solution for this problem.</p>
<p>Prerequisits:</p>
<ul>
<li>Docker knowledge</li>
<li>Microservice knowledge</li>
</ul>
<blockquote>
<p>TODO.</p>
</blockquote>
<h1 id="definitions-and-boundaries">Definitions and Boundaries</h1>
<p>This section provides general information about the project, the context and prerequisite knowledge. It gives an overview of the context as well as terminology and general definitions.</p>
<h2 id="context">Context</h2>
<blockquote>
<p>TODO: restructure to have better reading flow</p>
</blockquote>
<p>This project addresses the specific problem of declarative conversion of credentials to ensure authorized communication between services. The solution may be runnable on various platforms but will be implemented according to Kubernetes standards. Kubernetes<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is an orchestration platform that works with containerized applications. The solution introduces an operator pattern, as explained in Section <a href="#sec:kubernetes_operator">2.2.3</a></p>
<p>The deliverables of this and further projects may aid applications or APIs to communicate with each other despite different authentication mechanisms. As an example, this could be used to enable a modern web application that uses OpenID Connect (OIDC) as the authentication and authorization mechanism to communicate with a legacy application that was deployed on the Kubernetes cluster but not yet rewritten. This transformation of credentials (from OIDC to Basic Auth) is done by the solution of the projects instead of manual work which may introduc code changes to either service.</p>
<p>This specific project provides a proof of concept (PoC) with an initial version on a GitHub repository. The PoC demonstrates that it is possible to instruct an Envoy<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> proxy to communicate with an injected service to modify authentication credentials in-flight.</p>
<p>To use the proposed solution of this project, no service mesh or other complex layer is needed. The solution runs without those additional parts on a Kubernetes cluster. To provide service discovery, the default internal DNS capabilities of Kubernetes are sufficient.</p>
<h2 id="kubernetes">Kubernetes</h2>
<h3 id="introduction-1">Introduction</h3>
<p>Kubernetes is an open source platform that manages containerized workloads and applications. Workloads may be accessed via “Services” that use a DNS naming system. Kubernetes uses declarative definitions to compare the actual state of the system with the expected state <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<div id="fig:kubernetes_container_evolution" class="fignos">
<figure>
<img src="images/Kubernetes/Container_Evolution.png" data-short-caption="Kubernetes Container Evolution" alt="Figure 1: Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes (CNCF 2021). This image is licensed under the CC BY 4.0 license (Creative Commons 2021)." /><figcaption aria-hidden="true"><span>Figure 1:</span> Container and Deployment Evolution. Description of the evolution of deployments as found on the documentation website of Kubernetes <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>. This image is licensed under the CC BY 4.0 license <span class="citation" data-cites="cc:CCBY4.0">(Creative Commons 2021)</span>.</figcaption>
</figure>
</div>
<p>According to Kubernetes, the way of deploying applications has evolved. As shown in Figure <a href="#fig:kubernetes_container_evolution">1</a>, the “Traditional Era” was the time, when applications were deployed via FTP access and started manually (e.g. on an Apache webserver). Then the revolution to virtual machines came and technologies that could virtualize a whole operating system, such as VMWare, were born. The latest stage, “Container Era,” defines a new way deploying workloads by virtualizing processes instead of operating systems and therefore better use the given resources <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>.</p>
<p>Kubernetes is a major player, among others like “Docker Swarm” or “Cloud Foundry,” in “Container Deployment” as seen in Figure <a href="#fig:kubernetes_container_evolution">1</a> and supports teams with the following features according to the documentation <span class="citation" data-cites="github:kubernetesWebsite">(CNCF 2021)</span>:</p>
<ul>
<li><strong>Service discovery and load balancing</strong>: Use DNS names or IP addresses to route traffic to a container and if the traffic is high and multiple instances are available, Kubernetes does load balance the traffic</li>
<li><strong>Storage orchestration</strong>: Automatically provide storage in the form of mountable volumes</li>
<li><strong>Automated rollouts and rollbacks</strong>: When a new desired state is provided Kubernetes tries to achieve the state at a controlled rate and has the possibility of performing rollbacks</li>
<li><strong>Automatec bin packing</strong>: Kubernetes only needs to know how much CPU and RAM a workload needs and then takes care of placing the workload on a fitting node in the cluster</li>
<li><strong>Self-healing</strong>: If workloads are failing, Kubernetes tries to restart the applications and even kills services that do not respond to the configured health checks</li>
<li><strong>Secret and configuration management</strong>: Kubernetes has a store for sensitive data as well as configurational data that may change the behaviour of a workload</li>
</ul>
<p>The list of features is not complete. There are many concepts in Kubernetes which help to build complex deployment scenarios and enable teams to ship their applications in an agile manner.</p>
<p>Kubernetes works with containerized applications. In contrast to “plain” Docker, it orchestrates the applications and is responsible to reach the desired state depicted in the applications manifest files. Examples of such manifests can be viewed at: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#creating-a-deployment.</p>
<h3 id="terminology">Terminology</h3>
<p>In Table <a href="#tbl:kubernetes_terminology">1</a>, we state the most common Kubernetes terminology. The table provides a list of terms that will be used to explain concepts like the operator pattern in Section <a href="#sec:kubernetes_operator">2.2.3</a>.</p>
<div id="tbl:kubernetes_terminology" class="tablenos">
<table id="tbl:kubernetes_terminology" style="width:92%;">
<caption><span>Table 1:</span> Common Kubernetes Terminology </caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Docker</td>
<td>Container runtime. Enables developers to create images of applications. Those images are then run in an isolated environment. Docker images are often used in Kubernetes to define the application that Kubernetes should run.</td>
</tr>
<tr class="even">
<td>Kustomize</td>
<td>“Kustomize” is a special templating CLI to declaratively bundle Kubernetes manifests. It consists of a <code>kustomization.yaml</code> and various referenced manifest yaml files. It is declarative and does not allow dynamic structures. It helps administrators to template applications for Kubernetes.</td>
</tr>
<tr class="odd">
<td>Container</td>
<td>Smallest possible unit in a deployment. Contains the definition of the workload. A container consists of a container image, arguments, volumes and other specific information to carry out a task.</td>
</tr>
<tr class="even">
<td>Pod</td>
<td>Composed of multiple containers. Is ran by Kubernetes as an instance of a deployment. Pods may be scaled according to definitions or “pod scalers.” Highly coupled tasks are deployed together in a pod (i.e. multiple coupled containers in a pod).</td>
</tr>
<tr class="odd">
<td>Deployment</td>
<td>A deployment is a managed instance of a pod. Kubernetes will run the described pod with the desired replica count on the best possible worker node. Deployments may be scaled with auto-scaling mechanisms.</td>
</tr>
<tr class="even">
<td>Service</td>
<td>A service enables communciation with one or multiple pods. The service contains a selector that points to a certain number of pods and then ensures that the pods are accessable via a DNS name. The name is typically a combination of the servicename and the namespace (e.g. <code>my-service.namespace</code>).</td>
</tr>
<tr class="odd">
<td>Resource</td>
<td>A resource is something that can be managed by Kubernetes. It defines an API endpoint on the master node and allows Kubernetes to store a collection of such API objects. Examples are: <code>Deployment</code>, <code>Service</code> and <code>Pod</code>, to name a few of the built-in resources.</td>
</tr>
<tr class="even">
<td>CRD</td>
<td>A Custom Resource Definition (CRD) enables developers to extend the default Kubernetes API. With a CRD, it is possible to create own resources which creates an API endpoint on the Kubernetes API. An example of such a CRD is the <code>Mapping</code> resource of Ambassador<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</td>
</tr>
<tr class="odd">
<td>Operator</td>
<td>An operator is a software that manages Kubernetes resources and their lifecycle. Operators may use CRDs to define custom objects on which they react when some event (<code>Added</code>, <code>Modified</code> or <code>Deleted</code>) triggers on a resource. For a more in-depth description, see Section <a href="#sec:kubernetes_operator">2.2.3</a>.</td>
</tr>
<tr class="even">
<td>Watcher</td>
<td>A watcher is a constant connection from a client to the Kubernetes API. The watcher defines some search and filter parameters and receives events for the found resources.</td>
</tr>
<tr class="odd">
<td>Validator</td>
<td>A validator is a service that may reject the creation, modification or deletion of resources.</td>
</tr>
<tr class="even">
<td>Mutator</td>
<td>Mutators are called before Kubernetes validates and stores a resource. Mutators may return JSON patches <strong>RFC6902</strong> <span class="citation" data-cites="RFC6902">(Bryan and Nottingham 2013)</span> to instruct Kubernetes to modify a resource prior to validating and storing them.</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>TODO: UML of kubernetes parts</p>
</blockquote>
<h3 id="sec:kubernetes_operator">Operator</h3>
<p>An operator in Kubernetes is an extension to the Kubernetes API itself. A custom operator typically manages the whole lifecycle of an appliction it manages <span class="citation" data-cites="dobies:KubernetesOperators">(Dobies and Wood 2020)</span>. Such a custom operator can further be used to reconcile normal Kubernetes resources or any combination thereof.</p>
<p>Some examples of application operators are:</p>
<ul>
<li>Prometheus Operator<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>: Manages instances of Prometheus in a cluster</li>
<li>Postgres Operator<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>: Manages PostgreSQL clusters inside Kubernetes, with the support of multiple instance database clusters</li>
</ul>
<p>There exists a broad list of operators, which can be (partially) viewed on <a href="https://operatorhub.io/">operatorhub.io</a>.</p>
<div id="fig:kubernetes_operator_workflow" class="fignos">
<figure>
<img src="diagrams/sequences/aa65e382f6a2fe3087f6f2409dd66f0f.png" alt="Figure 2: Kubernetes Operator Workflow" /><figcaption aria-hidden="true"><span>Figure 2:</span> Kubernetes Operator Workflow</figcaption>
</figure>
</div>
<p>In Figure <a href="#fig:kubernetes_operator_workflow">2</a>, we depict the general workflow of an event that is managed by an operator. When an operator is installed and running on a Kubernetes cluster, it registers “Resource Watchers” with the API and receives notifications when the master node modifies resources a watched resource. The overviewed events are “Added,” “Modified” and “Deleted.” There are two additional events that may be returned by the API (“Error” and “Bookmark”) but they are typically not needed in an operator.</p>
<p>When the user interacts with the Kubernetes API (for example via the <code>kubectl</code> executable) and creates a new instance of a resource, the API will first call any “Mutator” in a serial manner. After the mutators, the API will call any “Validators” in parallel and if no validator objects against the creation, the API will then store the resource and tries to apply the transition for the new desired state. Now, the operator receives the notification about the watched resource and may interact with the event. Such an action may include to update resources, create more resources or even delete other instances.</p>
<h3 id="sec:kubernetes_sidecar">Sidecar</h3>
<p>According to <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">Burns and Oppenheimer (2016)</span>, the sidecar pattern is the most common pattern for multi-container deployments <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, sec. 4.1)</span>. Sidecars are containers that enhance the functionality of the main container in a pod. An example for such a sidecar is a log collector, that collects log files written to the file system and forwards them towards some log processing software <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, sec. 4.1)</span>. Another example is the Google CloudSQL Proxy<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, which provides access to a CloudSQL instance from a pod without routing the whole traffic through Kubernetes services.</p>
<div id="fig:kubernetes_sidecar" class="fignos">
<figure>
<img src="diagrams/component/e0da4a8fee732a0b7c6fb822bbe41198.png" data-short-caption="Example of a sidecar container" alt="Figure 3: Sidecar container extending a main container in a pod. As example, this could be a log collector , figure 1(Burns and Oppenheimer 2016, fig. 1)." /><figcaption aria-hidden="true"><span>Figure 3:</span> Sidecar container extending a main container in a pod. As example, this could be a log collector <span class="citation" data-cites="burns:DesignPatternsForContainerSystems">(Burns and Oppenheimer 2016, fig. 1)</span>.</figcaption>
</figure>
</div>
<p>The example shown in Figure <a href="#fig:kubernetes_sidecar">3</a> is extensible. Such sidecars may be injected by a mutator or an operator to extend functionality.</p>
<p>Common usecases for sidecars are controlling the data flow in a cluster in service mesh, providing access to secure locations or performing additional tasks such as collecting logs of an application. Since sidecars are tightly coupled to the original application, they scale with the Pod. It is not possible to scale a sidecar without scaling the Pod - and therefore the application - itself.</p>
<h3 id="sec:service_mesh">Service Mesh</h3>
<p>A “Service Mesh” is a dedicated infrastructure layer that handles intercommunication between services. It is responsible for the delivery of requests in a modern cloud application <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>. An example from the practice is “Istio”<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. When using Istio, the applications do not need to know if there is a service mesh installed or not. Istio will inject a sidecar (see Section <a href="#sec:kubernetes_sidecar">2.2.4</a>) into pods and handle the communication with the injected services.</p>
<p>The service mesh provides a set of features <span class="citation" data-cites="li:ServiceMesh">(Li et al. 2019, sec. 2)</span>:</p>
<ul>
<li><strong>Service discovery</strong>: The mechanism to locate and communicate with a workload / service. In a cloud environment, the location of services will likely change, thus the service mesh provides a way to access the services in the cloud.</li>
<li><strong>Load balancing</strong>: As an addition to the service discovery, the mesh provides load balancing mechanisms as is done by Kubernetes itself.</li>
<li><strong>Fault tolerance</strong>: The router in a service mesh is responsible to route traffic to healthy services. If a service is unavailable or even reports a crash, traffic should not be routed to this instance.</li>
<li><strong>Traffic monitoring</strong>: In contrast to the default Kubernetes possibilities, with a service mesh, the traffic from and to various services can be monitored in detail. This offers the opportunity to derive reports per target, success rates and other metrics.</li>
<li><strong>Circuit breaking</strong>: The ability to cut off an overloaded service and back off the remaining requests instead of totally failing the service under stress. A circuit breaker pattern measures the failure rate of a service and applies states to the service: “Closed” - requests are passed to the service, “Open” - requests are not passed to this instance, “Half-Open” - only a limited number is passed <span class="citation" data-cites="montesi:CircuitBreakers">(Montesi and Weber 2016, sec. 2)</span>.</li>
<li><strong>Authentication and access control</strong>: Through the control plane, a service mesh may define the rules of communication. It defines which services can communicate with one another.</li>
</ul>
<p>As observed in the list above, many of the features of a service mesh are already provided by Kubernetes. Service discovery, load balancing, fault tolerance and - though limited - traffic monitoring is already possible with Kubernetes. Introducing a service mesh into a cluster enables administrators to build more complex scenarios and deployments.</p>
<h2 id="authentication-and-authorization">Authentication and Authorization</h2>
<h3 id="sec:basic_auth">Basic (RFC7617)</h3>
<p>The <code>Basic</code> authentication scheme is a trivial authentication that accepts a username and a password encoded in Base64. To transmit the credentials, a construct with the schematics of <code>&lt;username&gt;:&lt;password&gt;</code> is created and inserted into the http request as the <code>Authorization</code> header with the prefix <code>Basic</code> <span class="citation" data-cites="RFC7617">(Reschke 2015, sec. 2)</span>. An example with the username <code>ChristophBuehler</code> and password <code>SuperSecure</code> would result in the following header:</p>
<blockquote>
<p><code>Authorization: Basic Q2hyaXN0b3BoQnVlaGxlcjpTdXBlclNlY3VyZQ==</code></p>
</blockquote>
<h3 id="sec:auth_oidc">OpenID Connect (OIDC)</h3>
<p>OpenID Connect is not defined in a RFC, the specification is provided by the OpenID Foundation (OIDF). OIDC however, builds on top of OAuth, which is defined by <strong>RFC6749</strong>.</p>
<p>OpenID Connect is an authenticating scheme, that builds upon the <code>OAuth 2.0</code> authorization protocol. OAuth itself is an authorization framework, that enables applications to gain access to a service (API or other) <span class="citation" data-cites="RFC6749">(Hardt and others 2012, abstract)</span>. OAuth 2.0 deals with authorization only and grants access to data and features on a specific application. OAuth by itself does not define <em>how</em> the credentials are transmitted and exchanged <span class="citation" data-cites="RFC6749">(Hardt and others 2012)</span>. OIDC adds a layer on top of OAuth 2.0 that defines <em>how</em> these credentials must be exchanged. This adds login and profile capabilities to any application that uses OIDC <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014)</span>.</p>
<div id="fig:oidc_code_flow" class="fignos">
<figure>
<img src="diagrams/sequences/41c9b09f4e1f4ab638e875ce4e6c8e37.png" data-short-caption="OIDC code flow" alt="Figure 4: OIDC code authorization flow (Sakimura et al. 2014). Only contains the credential flow, without the explicit OAuth part. OAuth handles the authorization whereas OIDC handles the authentication." /><figcaption aria-hidden="true"><span>Figure 4:</span> OIDC code authorization flow <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014)</span>. Only contains the credential flow, without the explicit OAuth part. OAuth handles the authorization whereas OIDC handles the authentication.</figcaption>
</figure>
</div>
<p>When a user wants to authenticate himself with OIDC, one of the possible “flows” is the “Authorization Code Flow” <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.1)</span>. Other possible flows are the “Implicit Flow” <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.2)</span> and the “Hybrid Flow” <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.3)</span>. Figure <a href="#fig:oidc_code_flow">4</a> depicts the “Authorization Code Flow.” A user that wants to access a certain resource on a relying party (i.e. something that relies on the information about the user) and is not authenticated and authorized, the relying party forwards the user to the identity provider (IdP). The user provides his credentials to the IdP and is returned to the relying party with an authorization code. The relying party can then exchange the authorization code to valid tokens on the token endpoint of the IdP. Typically, <code>access_token</code> and <code>id_token</code> are provided. While the <code>id_token</code> must be a JSON Web Token (JWT) <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 2)</span>, the <code>access_token</code> can be in any format <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014, sec. 3.3.3.8)</span>.</p>
<p>An example of an <code>id_token</code> in JWT format may be:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre>
<p>The stated JWT token contains:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;alg&quot;</span><span class="fu">:</span> <span class="st">&quot;HS256&quot;</span><span class="fu">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;typ&quot;</span><span class="fu">:</span> <span class="st">&quot;JWT&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="st">&quot;1234567890&quot;</span><span class="fu">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;John Doe&quot;</span><span class="fu">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;iat&quot;</span><span class="fu">:</span> <span class="dv">1516239022</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<h1 id="state-of-the-art-the-practice-and-deficiencies">State of the Art, the Practice and Deficiencies</h1>
<p>This section gives an overview over the current state of the art, the practice, as well as the deficiencies to a desired situation.</p>
<h2 id="state-of-the-art">State of the Art</h2>
<p>In cloud environments, a problem that is solved is the transmission of data from one point to another. Kubernetes, for example, uses “Services” that provide a DNS name for a specified workload. For service meshes, additionally a sidecar is injected into the Pod that contains - in the case of “Istio” - an Envoy proxy to handle data transmission.</p>
<p>In terms of authentication and authorization, there exist a variety of schemes that enable an application to authenticate and authorize their users. OpenID Connect (OIDC) (see Section <a href="#sec:auth_oidc">2.3.2</a>) is a modern authentication scheme, that builds upon OAuth 2.0, that in turn handles authorization <span class="citation" data-cites="spec:OIDC">(Sakimura et al. 2014)</span>.</p>
<p>Modern software architectures that are specifically designed for the cloud are called “Cloud Native Applications” (CNA). <span class="citation" data-cites="kratzke:CloudNativeApplications">Kratzke and Peinl (2016)</span> define a CNA as:</p>
<blockquote>
<p>“A cloud-native application is a distributed, elastic and horizontal scalable system composed of (micro)services which isolates state in a minimum of stateful components. The application and each self-contained deployment unit of that application is designed according to cloud-focused design patterns and operated on a self-service elastic platform.” <span class="citation" data-cites="kratzke:CloudNativeApplications">(Kratzke and Peinl 2016, sec. 3)</span>.</p>
</blockquote>
<p>However, with CNAs and the general movement to cloud environments and digitalization, not all applications get that chance to adjust. For various reasons like budget, time or complexity, legacy applications and monoliths are not refactored or re-written before they are deployed into a cloud environment. If the legacy applications are mixed with modern systems, then the need of “translation” arises. Assuming, that the modern part is a secure application, that uses OIDC to authorize its users and the application needs to fetch data from the legacy system that does not understand OIDC, code changes must be made. Following the previous assumption, the code changes will likely be introduced into the modern application, since it is better maintainable and deployable than the legacy monolith. Hence, the modern application receives changes that may introduce new bugs or security vulnerabilities.</p>
<div id="fig:is_solution_components" class="fignos">
<figure>
<img src="diagrams/component/32d39edc1a049309b9656b207affa129.png" data-short-caption="Microservice Architecture with legacy components" alt="Figure 5: Microservice Architecture that contains modern applications as well as legacy services." /><figcaption aria-hidden="true"><span>Figure 5:</span> Microservice Architecture that contains modern applications as well as legacy services.</figcaption>
</figure>
</div>
<p>We consider the components in Figure <a href="#fig:is_solution_components">5</a>:</p>
<ul>
<li><strong>User</strong>: A person with access to the application</li>
<li><strong>Client</strong>: A modern single page application (SPA)</li>
<li><strong>IAM</strong>: Identity Provider for the solution (does not necessarily reside in the same cloud)</li>
<li><strong>Service A</strong>: A modern API application and primary access point for the client</li>
<li><strong>Service B</strong>: Legacy service that is called by service a to fetch some additional data</li>
</ul>
<p>In the practice, we encountered the stated scenario at various points in time. Legacy services may not be the primary use-case, a nother case is the usage of third party applications which only support certain authentication mechanisms and the code is not accessable.</p>
<div id="fig:is_solution_process" class="fignos">
<figure>
<img src="diagrams/sequences/6faa74afc76899917ebd60382cc3b148.png" data-short-caption="Current process of legacy communication" alt="Figure 6: Current state of the art of accessing legacy systems from modern services with differing authentication schemes." /><figcaption aria-hidden="true"><span>Figure 6:</span> Current state of the art of accessing legacy systems from modern services with differing authentication schemes.</figcaption>
</figure>
</div>
<p>The process in Figure <a href="#fig:is_solution_process">6</a> shows the process of communication in such a described scenario. In Figure <a href="#fig:is_solution_process">6</a>, the “Client” is the single page application (SPA), that authenticates against an arbitrary Identity and Access Management System (IAM). “Service A” is the modern backend that supports the client as backend API. Therefore, “Service A” provides functionality for the client. “Service B” is a legacy application, for example an old ERP with order information, that was moved into the cloud, but is not refactored nor rewritten to communicate with modern authentication technologies.</p>
<p>In this scenario, the client calls some API on “Service A” that then will call “Service B” to get additional information to present to the user. Since the client and “Service A” communicate with the same authentication technology, the call is straight forward. The client authenticates himself and obtains an access token. When calling the service (“Service A”), the token is transmitted and the service can check with the IAM if the user is authorized to access the system. When “Service A” then calls “Service B” for additional information, it needs to translate the user provided credentials to a format that “Service B” understands. In the provided example, “Service B” is only able to handle Basic Authentication, as explained in Section <a href="#sec:basic_auth">2.3.1</a>. This means, if “Service A” wants to communicate with “Service B,” it must implement some translation logic to change the credentials to a format that B understands. This introduces code changes to “Service A,” since “Service B” is a legacy application that is not maintainable.</p>
<h2 id="the-practice">The Practice</h2>
<p>In practice, no current solution exists, that allows credentials to be transformed between authentication schemes. The service mesh “Istio” provides a mechanism to secure services that communicate with mTLS (mutual TLS) <span class="citation" data-cites="istio:website:mtls">(Istio Authors 2021b)</span> as well as an external mechanism to provide custom authentication and authorization capabilities <span class="citation" data-cites="istio:website:custom-authz">(Istio Authors 2021a)</span>. This works well when all applications in the system share the same authentication scheme. As soon as two or more schemes are in place, the need for transformation arises again.</p>
<h2 id="sec:deficiencies">Deficiencies</h2>
<p>The situation described in the previous sections introduces several problems. It does not matter if “Service B” is a third party application to which no code changes can be applied to, or if it is a legacy application that cannot be updated for the time being. Most likely, the code change to provide the ability to communicate will be introduced into “Service A.” This adds the risk of errors since new code must be produced, which would not be necessary if the legacy service would be refactored. Also, changing “Service A” to communicate with B may be a feasible solution in a small setup. But as the landscape of the microservice architecture grows, this solution does not scale well. The matrix problem <span class="math inline"><em>X</em> services * <em>Y</em> authentication methods</span> describes this problematic. As the landscape and the different methods of authentication grows, it is not a feasible solution to implement each and every authentication scheme in all the services.</p>
<p>Another issue that emerges with this transformation of credentials: The credentials leak into the trust zone. As long as each service is in the same trust zone (for example in the same data-center in the same cluster behind the same API gateway), this may not be problematic. As soon as communication is between data centers, the communication and the credentials must be protected. It is not possible to create a zero trust environment with the need of knowledge about the targets authentication schemes.</p>
<p>The usage of a service mesh to mitigate the problem is not an option since the initial problem of transforming credential still persists. Service meshes may provide a way to secure communication between services, but they are not able to transform credentials to a required format for any legacy application. Furthermore, service meshes introduce configurational complexity to the system which, in our opinion, is not needed without a clear usecase for a service mesh.</p>
<h1 id="distributed-authentication-mesh">Distributed Authentication Mesh</h1>
<p>This section gives a general overview of the proposed solution. Furthermore, boundaries of the solution are provided along with common software engineering elements like requirements, non-functional requirements and the documentation of the architecture.</p>
<p>The proposed architecture may be used as generic description for a solution to the described problem. For this project, the solution is implemented specifically to work within a Kubernetes cluster. The delivery of this project is a proof of concept to provide insights into the general topic of manipulating HTTP requests in-flight.</p>
<h2 id="definition">Definition</h2>
<p>The solution to solve the stated problems in Section <a href="#sec:deficiencies">3.3</a> must be able to transform arbitrary credentials into a format that the target service understands. For this purpose, the architecture contains a service which runs as a sidecar among the target service. This sidecar intercepts requests to the target and transforms the Authorization HTTP header. The sidecar is - like in a service mesh - used to intercept inbound and outbound traffic.</p>
<p>However, the solution <strong>must not</strong> interfere with the data flow itself. The problem of proxying data from point A to B is a well solved problem. In the given work, an Envoy proxy is used to deliver data between the services. Envoy allows the usage of an external service to modify requests in-flight.</p>
<h2 id="requirements">Requirements</h2>
<p>In Table <a href="#tbl:functional-requirements">2</a>, we present the list of requirements (REQ) for the proposed solution.</p>
<div id="tbl:functional-requirements" class="tablenos">
<table id="tbl:functional-requirements" style="width:89%;">
<caption><span>Table 2:</span> Functional Requirements </caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>REQ 1</td>
<td>The translator module must be able to transform given credentials into the specified common language and the common format back into valid credentials.</td>
</tr>
<tr class="even">
<td>REQ 2</td>
<td>The translator is injected as a sidecar into the solution. In Kubernetes this is done via an operator.</td>
</tr>
<tr class="odd">
<td>REQ 3</td>
<td>Beside the translator, an Envoy proxy is injected to the service inquestion to handle the data flow. This injection is also performed by the operator.</td>
</tr>
<tr class="even">
<td>REQ 4</td>
<td>Translators do only modify HTTP headers, they do not interfere with the data that is transmitted. Any information that needs to be forwarded must be within the HTTP headers.</td>
</tr>
<tr class="odd">
<td>REQ 5</td>
<td></td>
</tr>
<tr class="even">
<td>REQ 6</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>It is important to note that the implemented proof of concept (PoC) will not meet all requierements. Further work is needed to implement a solution according to the architecture that adheres the stated requirements.</p>
<h2 id="non-functional-requirements">Non-Functional Requirements</h2>
<p>In Table <a href="#tbl:non-functional-requirements">3</a>, we show the non-functional requirements (NFR) for the proposed solution.</p>
<div id="tbl:non-functional-requirements" class="tablenos">
<table id="tbl:non-functional-requirements" style="width:89%;">
<caption><span>Table 3:</span> Non-Functional Requirements </caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NFR 1</td>
<td>First and foremost, the solution <strong>must not</strong> be less secure than current solutions.</td>
</tr>
<tr class="even">
<td>NFR 2</td>
<td>The solution must adhere to current best practices and security mechanisms. Furthermore, it <strong>must</strong> be implemented with security issues as stated in the OWASP Top Ten (<a href="https://owasp.org/www-project-top-ten" class="uri">https://owasp.org/www-project-top-ten</a>) in mind.</td>
</tr>
<tr class="odd">
<td>NFR 3</td>
<td>The concept of the solution is applicable to cluster orchestration software other than Kubernetes. The architecture provides a general way of solving the stated problem instead of giving a proprietary solution for one vendor.</td>
</tr>
<tr class="even">
<td>NFR 4</td>
<td>The translation of the credentials should not extensively impact the timeframe of an arbitrary request. In production mode, the additional time to check and transform the credentials should not extend 100ms.</td>
</tr>
<tr class="odd">
<td>NFR 5</td>
<td>The solution is modular. It can be extended with additional “translators” which provide the means of transforming the given credentials to other target formats.</td>
</tr>
<tr class="even">
<td>NFR 6</td>
<td>The solution may run with or without a service mesh. It is a goal that the solution can run without a service mesh to reduce the overall complexity, but if a service mesh is already in place, the solution must be able to work with the provided elements.</td>
</tr>
<tr class="odd">
<td>NFR 7</td>
<td>The architecture must be scaleable. The provided software must be able to scale according to the business needs of the overall system.</td>
</tr>
<tr class="even">
<td>NFR 8</td>
<td>Each translator should only handle one authentication scheme to ensure separation of concerns and scalability of the whole solution.</td>
</tr>
<tr class="odd">
<td>NFR 9</td>
<td>The solution</td>
</tr>
</tbody>
</table>
</div>
<p>Like the requirements in Table <a href="#tbl:functional-requirements">2</a>, the PoC will not meet all NFRs that are stated in Table <a href="#tbl:non-functional-requirements">3</a>. Further work is needed to complete the PoC to a production ready software.</p>
<h2 id="contrast">Contrast</h2>
<p>To distinguish this solution from other software, this sections gives a contrast to two specific topics. The given topics stand for a general architectural idea and the contrast to the presented solution.</p>
<h3 id="saml">SAML</h3>
<p>The “Security Assertion Markup Language” (SAML) is a so called “Federated Identity Management” (FIdM) standard. SAML, OAuth and OIDC represent the three most popular FIdm standards <span class="citation" data-cites="naik:SAMLandFIdM">(Naik and Jenkins 2017)</span>. SAML is an XML framework for transmitting user data, such as authentication, entitlement and other attributes, between services and organizations <span class="citation" data-cites="naik:SAMLandFIdM">(Naik and Jenkins 2017)</span>.</p>
<p>While SAML is a partial solution for the stated problem, it does not cover the use case when credentials need to be transformed to communicate with a legacy system. SAML enables services to share identities in a trustful way but all communicating partners must implement the SAML protocol to be part of the network. This project addresses the specific transformation of credentials into a format for some legacy systems. The basic idea of SAML however, may be used as a baseline of security and the general idea of processing identities.</p>
<h3 id="sec:ws-deathstar">WS-*</h3>
<p>The term “WS-*” contains a broad class of specifications within the WSDL/SOAP context. The specifications were created by the World Wide Web Consortium (W3C) but never finished and officially published.</p>
<p>The “Simple Object Access Protocol” (SOAP) is a protocol to exchange information between services in an XML encoded message <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>. It provides a way of communication between web services. A SOAP message consists of an “envelope” that contains a “body” and an optional “header” to transfer encoded objects <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>. An example SOAP message from <span class="citation" data-cites="curbera:SOAP-and-WSDL">Curbera et al. (2002)</span> looks like this:</p>
<pre><code>POST /travelservice
SOAPAction: &quot;http://www.acme-travel.com/checkin&quot;
Content-Type: text/xml; charset=&quot;utf-8&quot;
Content-Length: nnnn

&lt;SOAP:Envelope xmlns:SOAP=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
  &lt;SOAP:Body&gt;
    &lt;et:eTicket xmlns:et=&quot;http://www.acme-travel.com/eticket/schema&quot;&gt;
      &lt;et:passengerName first=&quot;Joe&quot; last=&quot;Smith&quot;/&gt;
      &lt;et:flightInfo
        airlineName=&quot;AA&quot;
        flightNumber=&quot;1111&quot;
        departureDate=&quot;2002-01-01&quot;
        departureTime=&quot;1905&quot;/&gt;
    &lt;/et:eTicket&gt;
  &lt;/SOAP:Body&gt;
&lt;/SOAP:Envelope&gt;</code></pre>
<p>The “Web Services Description Language” (WSDL), however, is an XML based description of a web service. The goal of WSDL is to provide a description of methods that may be called on a web service <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>. WSDL fills the needed endpoint description that SOAP is missing. While SOAP provides basic communication, WSDL defines the exact methods that can be called on an endpoint <span class="citation" data-cites="curbera:SOAP-and-WSDL">(Curbera et al. 2002)</span>.</p>
<p>The proposed solution differs from WS-* such that there is no exact specification needed for the target service. While the solution contains a common domain language - a SOAP like protocol to encode data - it does not specify the endpoints of a service. The solution merely interacts with the HTTP request that targets a specific service and transforms the credentials from the common format to the specific format. Of course, certain authentication schemes need specific information to generate their credentials out of the data.</p>
<h2 id="architecture">Architecture</h2>
<p>The following sections provide an architectural overview over the proposed solution. The solution is described in prosa text, as well as usual software engineering diagrams with explanations. First, a description of the solution gives an intro about the idea, then the architecture shows the general overview of the solution followed by sequence and communication definitions.</p>
<p>The reader should note, that the proposed architecture does not match the implementation of the PoC to the full extent. The goal of this project is to provide a generalizable idea to implement such a solution, while the PoC proves the ability of modifying HTTP requests in-flight.</p>
<h3 id="brief-description">Brief Description</h3>
<p>In general, when some service wants to communicate with another service and the user does not need to authenticate himself for every service, a federated identity is used. This means, that at some point, the user validates his own identity and is then authenticated in the whole zone of trust.</p>
<p>To achieve such a federated identity with diverging authentication schemes, the solution converts validated credentials to a common language format. This format, in conjunction with a proof of the sender, validates the identity over the wire in the communication between services without the need of additional authentication. When all parties of a communication are trusted through verification, no information about the effective credentials may leak into the communication between services.</p>
<p>The basic idea of the solution is to remove any credentials from an outgoing HTTP request with the common format of the users identity and replace the common format in the ingoing HTTP request into the valid credentials of the given scheme.</p>
<p>In the case of Kubernetes, this additional software is injected via an operator as a sidecar. The operator watches for creation of deployments and services and orchestrates the configuration of the sidecars. The application gets a sidecar for the communication (an Envoy proxy) and for each authentication scheme that the target service supports, it receives a “translator” sidecar that handles the conversion from the common format to the specific scheme.</p>
<h3 id="use-case">Use Case</h3>
<p>The usefulness of such a solution shows when “older” or monolythic software moves to the cloud or when third party software is used that provides no accessable source code.</p>
<p><strong>Communicate with legacy software</strong></p>
<p>Precondition: Cloud native application and legacy software are deployed with their respective manifests and the sidecars are running.</p>
<ol type="1">
<li>The user is authenticated against the CNA</li>
<li>The user tries to access a resource on the legacy software</li>
<li>The CNA creates a request and “forwards” the credentials of the user</li>
<li>The envoy proxy intercepts the request and forwards the credentials to the transformer</li>
<li>The transformer verifies the credentials and transforms them into a common format</li>
<li>The envoy proxy replaces the headers and forwards the request</li>
<li>The receiving envoy proxy forwards the common format to the translator of the target</li>
<li>The translator casts the credentials into the specific authentication scheme credentials</li>
<li>The receiving envoy proxy forwards the request with the updated HTTP headers</li>
</ol>
<p>Postcondition: The communication has taken place and no credentials have left the source service (CNA). Furthermore, the legacy service does not know, what credentials or what specific authentication scheme was used.</p>
<p>This use case can be changed such that the receiving service is not a legacy software but an old and non-maintained application that is deployed into a cloud environment without refactoring.</p>
<h3 id="system-architecture">System Architecture</h3>
<h3 id="sequences">Sequences</h3>
<h3 id="communication">Communication</h3>
<p>The communication between the envoy proxies must be secured. Furthermore, the identity that is transformed over the wire must be tamper proof. Two established formats would suffice: “SAML” and “JWT Tokens.” While both contain the possibility to hash their contents and thus secure them against modification, JWT tokens are better designed for HTTP headers. In current OIDC environments, JWT tokens are used as access and/or identity tokens. They provide a secure environment with public and private claim names <span class="citation" data-cites="RFC7519">(Jones, Bradley, and Sakimura 2015, sec. 4.2, sec. 4.3)</span>.</p>
<h2 id="implementation-proof-of-concept-poc">Implementation Proof of Concept (PoC)</h2>
<p>To provide a proof that the general idea of the solution is possible, a PoC is implemented during the work of this project. The PoC addresses the following risks and questions:</p>
<ul>
<li>Is it possible intercept HTTP requests to an arbitrary service</li>
<li>Is it further possible to modify the HTTP headers of the request</li>
<li>Can a sidecar service transform given credentials from one format to another
<ul>
<li>In the PoC, an OIDC access token is translated into static basic auth credentials</li>
<li>No common language format is implemented or used in the PoC</li>
</ul></li>
<li>Can a custom operator inject the following elements
<ul>
<li>The correct configuration for Envoy to use external authentication</li>
<li>The translator module to transform the credentials</li>
</ul></li>
</ul>
<p>Based on the results of the PoC, the following further work may be realized:</p>
<ul>
<li>Specify the concrete common domain language to transport identities</li>
<li>Implement a secure way of transporting identities that is tamper-proof</li>
<li>Provide a production ready solution of some translators and the operator</li>
<li>Integrate the solution with a service mesh</li>
<li>Provide a production ready documentation of the solution</li>
<li>Further investiage the possibility of hardening the communication between services (e.g. with mTLS)</li>
</ul>
<p>The following sections will describe the parts of the PoC and their specific implementation details.</p>
<h3 id="showcase-application">Showcase Application</h3>
<p>The showcase application is a demo application to show the need and the particular usecase of the solution. The application resides in an open source repository under <a href="https://github.com/WirePact/poc-showcase-app" class="uri">https://github.com/WirePact/poc-showcase-app</a>.</p>
<p>When installed in a Kubernetes cluster, the user can open (depending on the local configuration) the URL to the frontend application<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<div id="fig:impl_components_showcase_app" class="fignos">
<figure>
<img src="diagrams/component/cca01766db54ff649e950b7c09fb6c53.png" alt="Figure 7: Component Diagram of the Showcase Application" /><figcaption aria-hidden="true"><span>Figure 7:</span> Component Diagram of the Showcase Application</figcaption>
</figure>
</div>
<p>Figure <a href="#fig:impl_components_showcase_app">7</a> gives an overview over the components in the showcase application. The system contains an ASP.Net Razor Page<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> application as the frontend, an ASP.Net API application with configured Zitadel<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> OIDC authentication as “modern” backend service and another ASP.Net API application that only supports basic authentication as “legacy” backend. The frontend can only communicate with the modern API and the modern API is able to call an additional service on the legacy API.</p>
<div id="fig:seq_showcase_call" class="fignos">
<figure>
<img src="diagrams/sequences/42709d8c02bb2a77c85b152d106214b0.png" alt="Figure 8: Sequence Diagram of the Showcase Call" /><figcaption aria-hidden="true"><span>Figure 8:</span> Sequence Diagram of the Showcase Call</figcaption>
</figure>
</div>
<p>In Figure <a href="#fig:seq_showcase_call">8</a>, we show the process of a user call in the showcase application. The user opens the web application and authenticates himself with Zitadel. After that, the user is presented with the application and can click the “Call API” button. The frontend application will call the modern backend API with the OIDC token and asks for customer and order data. The customer data is present on the modern API so it is directly returned. To query order data, the modern service relies on a legacy application which is only capable of basic authentication. Depending on the configuration (i.e. the environment variable <code>USE_WIREPACT</code>), the modern service will call the legacy one with either transformed basic auth credentials (when <code>USE_WIREPACT=false</code>) or with the presented OIDC token (otherwise). Either way, the legacy API receives basic auth credentials and returns the data which then in turn is returned and presented to the user.</p>
<p>To install and run the showcase application without any interference of the operator or the rest of the solution, follow the installation guide in the readme on <a href="https://github.com/WirePact/poc-showcase-app" class="uri">https://github.com/WirePact/poc-showcase-app</a>.</p>
<h3 id="envoy-sidecar">Envoy Sidecar</h3>
<h3 id="translator">Translator</h3>
<h3 id="operator">Operator</h3>
<h3 id="poc-composition">PoC Composition</h3>
<blockquote>
<p>TODO: Explain the whole PoC composition (how to run and stuff with operator).</p>
</blockquote>
<h1 id="evaluation">Evaluation</h1>
<blockquote>
<p>TODO: show in an evaluation, that the provided solution is working and improves the situation</p>
</blockquote>
<h1 id="further-work">Further work</h1>
<ul>
<li>create common domain model for user</li>
<li>use this domain language model to translate credentials from and to a specific implementation</li>
<li>use JWT to harden these credentials (signing)</li>
<li>operator must create and deliver keys</li>
<li>operator must have set of public keys</li>
</ul>
<h1 id="grober-roter-faden-projektbericht">Grober Roter Faden Projektbericht</h1>
<ol type="1">
<li>Introduction
<ul>
<li>Das Erreichte und den Überblick der Arbeit wiedergeben</li>
<li>Erklären wie die Arbeit aufgebaut ist und welche Details wo zu finden sind</li>
</ul></li>
<li>Einführung ins Thema
<ul>
<li>Leser ausbilden</li>
<li>Backgroundinformationen liefern</li>
<li>Context der Arbeit</li>
<li>Begrifflichkeiten erklären</li>
</ul></li>
<li>IST / SOLL Beschreibung
<ul>
<li>Was gibt es</li>
<li>Wie arbeit die Leute</li>
<li>Wo sind die Defizite</li>
</ul></li>
<li>Wie lösen wir die Probleme
<ul>
<li>Planung der Software (Diagramme etc.)</li>
<li>Wie die Lösung aussieht</li>
<li>Umsetzung der Konzepte</li>
</ul></li>
<li>Nachweis
<ul>
<li>Beweis anführen, dass das vorgeschlagene Konzept funktioniert</li>
<li>Beispiele nutzen um Leute abzuholen</li>
</ul></li>
<li>Conclusion
<ul>
<li>Ausblick (Referenz auf weitere Projektarbeit)</li>
<li>Was man gemacht hat (klassischer Paperdiamant)</li>
</ul></li>
</ol>
<h1 id="todos">Todos</h1>
<p>Following the description of the current situation, a definition of the should situation gives an overview of the proposed solution.</p>
<ul>
<li>Describe the IS situation.</li>
<li>Describe the SHOULD situation.</li>
<li>describe service mesh (image from referecne could be used)</li>
</ul>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-RFC6902" class="csl-entry" role="doc-biblioentry">
Bryan, Paul, and Mark Nottingham. 2013. <span>“Javascript Object Notation (<span>JSON</span>) Patch.”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc6902">https://tools.ietf.org/html/rfc6902</a>.
</div>
<div id="ref-burns:DesignPatternsForContainerSystems" class="csl-entry" role="doc-biblioentry">
Burns, Brendan, and David Oppenheimer. 2016. <span>“Design Patterns for Container-Based Distributed Systems.”</span> In <em>8th <span>USENIX</span> Workshop on Hot Topics in Cloud Computing (HotCloud 16)</em>. Denver, CO: <span>USENIX</span> Association. <a href="https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns">https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns</a>.
</div>
<div id="ref-github:kubernetesWebsite" class="csl-entry" role="doc-biblioentry">
CNCF. 2021. <span>“Kubernetes Website.”</span> <em>GitHub Repository</em>. <a href="https://github.com/kubernetes/website">https://github.com/kubernetes/website</a>; GitHub.
</div>
<div id="ref-cc:CCBY4.0" class="csl-entry" role="doc-biblioentry">
Creative Commons. 2021. <span>“Attribution 4.0 International (CC BY 4.0).”</span> <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>.
</div>
<div id="ref-curbera:SOAP-and-WSDL" class="csl-entry" role="doc-biblioentry">
Curbera, F., M. Duftler, R. Khalaf, W. Nagy, N. Mukhi, and S. Weerawarana. 2002. <span>“Unraveling the Web Services Web: An Introduction to <span>SOAP</span>, <span>WSDL</span>, and <span>UDDI</span>.”</span> <em><span>IEEE</span> Internet Computing</em> 6 (2): 86–93. <a href="https://doi.org/10.1109/4236.991449">https://doi.org/10.1109/4236.991449</a>.
</div>
<div id="ref-dobies:KubernetesOperators" class="csl-entry" role="doc-biblioentry">
Dobies, Jason, and Joshua Wood. 2020. <em>Kubernetes Operators: Automating the Container Orchestration Platform</em>. " O’Reilly Media, Inc.".
</div>
<div id="ref-RFC6749" class="csl-entry" role="doc-biblioentry">
Hardt, Dick, and others. 2012. <span>“The <span>OAuth</span> 2.0 Authorization Framework.”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a>.
</div>
<div id="ref-istio:website:custom-authz" class="csl-entry" role="doc-biblioentry">
Istio Authors. 2021a. <span>“External Authorization.”</span> <em>Istio</em>. <a href="https://istio.io/latest/docs/tasks/security/authorization/authz-custom/">https://istio.io/latest/docs/tasks/security/authorization/authz-custom/</a>.
</div>
<div id="ref-istio:website:mtls" class="csl-entry" role="doc-biblioentry">
———. 2021b. <span>“Mutual TLS Migration.”</span> <em>Istio</em>. <a href="https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/">https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/</a>.
</div>
<div id="ref-RFC7519" class="csl-entry" role="doc-biblioentry">
Jones, Michael B., Bradley John, and Nat Sakimura. 2015. <span>“<span>JSON</span> Web Token (<span>JWT</span>).”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>.
</div>
<div id="ref-kratzke:CloudNativeApplications" class="csl-entry" role="doc-biblioentry">
Kratzke, N., and R. Peinl. 2016. <span>“ClouNS - a Cloud-Native Application Reference Model for Enterprise Architects.”</span> In <em>2016 IEEE 20th International Enterprise Distributed Object Computing Workshop (EDOCW)</em>, 1–10. <a href="https://doi.org/10.1109/EDOCW.2016.7584353">https://doi.org/10.1109/EDOCW.2016.7584353</a>.
</div>
<div id="ref-li:ServiceMesh" class="csl-entry" role="doc-biblioentry">
Li, W., Y. Lemieux, J. Gao, Z. Zhao, and Y. Han. 2019. <span>“Service Mesh: Challenges, State of the Art, and Future Research Opportunities.”</span> In <em>2019 IEEE International Conference on Service-Oriented System Engineering (SOSE)</em>, 122–25. <a href="https://doi.org/10.1109/SOSE.2019.00026">https://doi.org/10.1109/SOSE.2019.00026</a>.
</div>
<div id="ref-montesi:CircuitBreakers" class="csl-entry" role="doc-biblioentry">
Montesi, Fabrizio, and Janine Weber. 2016. <span>“Circuit Breakers, Discovery, and <span>API</span> Gateways in Microservices.”</span> <em>CoRR</em> abs/1609.05830. <a href="http://arxiv.org/abs/1609.05830">http://arxiv.org/abs/1609.05830</a>.
</div>
<div id="ref-naik:SAMLandFIdM" class="csl-entry" role="doc-biblioentry">
Naik, N., and P. Jenkins. 2017. <span>“Securing Digital Identities in the Cloud by Selecting an Apposite Federated Identity Management from <span>SAML</span>, <span>OAuth</span> and <span>OpenID</span> Connect.”</span> In <em>2017 11th International Conference on Research Challenges in Information Science (RCIS)</em>, 163–74. <a href="https://doi.org/10.1109/RCIS.2017.7956534">https://doi.org/10.1109/RCIS.2017.7956534</a>.
</div>
<div id="ref-RFC7617" class="csl-entry" role="doc-biblioentry">
Reschke, Julian. 2015. <span>“The ’Basic’ <span>HTTP</span> Authentication Scheme.”</span> RFC. Internet Engineering Task Force <span>IETF</span>. <a href="https://tools.ietf.org/html/rfc7617">https://tools.ietf.org/html/rfc7617</a>.
</div>
<div id="ref-spec:OIDC" class="csl-entry" role="doc-biblioentry">
Sakimura, Natsuhiko, John Bradley, Mike Jones, Breno De Medeiros, and Chuck Mortimore. 2014. <span>“Openid Connect Core 1.0.”</span> Spec. The <span>OpenID</span> Foundation <span>OIDF</span>. <a href="https://openid.net/specs/openid-connect-core-1_0.html">https://openid.net/specs/openid-connect-core-1_0.html</a>.
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>According to the matrix problem: <span class="math inline"><em>X</em> services * <em>Y</em> authentication methods</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://kubernetes.io/" class="uri">https://kubernetes.io/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://www.envoyproxy.io/" class="uri">https://www.envoyproxy.io/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://www.getambassador.io/" class="uri">https://www.getambassador.io/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://github.com/prometheus-operator/prometheus-operator" class="uri">https://github.com/prometheus-operator/prometheus-operator</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://github.com/zalando/postgres-operator" class="uri">https://github.com/zalando/postgres-operator</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="https://github.com/GoogleCloudPlatform/cloudsql-proxy" class="uri">https://github.com/GoogleCloudPlatform/cloudsql-proxy</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="https://istio.io/" class="uri">https://istio.io/</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>In the example it is https://kubernetes.docker.internal since this is the local configured URL for “Docker Desktop”<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p> <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/" class="uri">https://docs.microsoft.com/en-us/aspnet/core/razor-pages/</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p><a href="https://zitadel.ch" class="uri">https://zitadel.ch</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
